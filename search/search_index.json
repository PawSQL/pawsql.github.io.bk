{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"license/","text":"License \u00b6 MIT License Copyright \u00a9 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"license/#license","text":"MIT License Copyright \u00a9 2016-2022 Martin Donath Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"readme/","text":"PawSQL optimizes SQL queries by One Click PawSQL Advisor \u00b6 In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Rules-based SQL auditing , targeting correctness auditing and performance optimization. Rewrite optimization , recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation , based on input SQL syntax, database objects and statistics information. What-if validation to ensure gaining better performance after SQL rewriting and indexing recommendations. Get started \u00b6 Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization recommendations will be presented to you. Paw Index Advisor \u00b6 Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if validation , make sure indexes recommended be used in later query execution Get started \u00b6 Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter [ Paw Index Advisor ] in martketplace and click install Configure the running parameters of Paw Index Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for minutes and recommended indexes will be presented to you to accelerate your database queries. Claim: PawSQL Advisor and Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Readme"},{"location":"readme/#pawsql-advisor","text":"In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"PawSQL Advisor"},{"location":"readme/#features","text":"Rules-based SQL auditing , targeting correctness auditing and performance optimization. Rewrite optimization , recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation , based on input SQL syntax, database objects and statistics information. What-if validation to ensure gaining better performance after SQL rewriting and indexing recommendations.","title":"Features"},{"location":"readme/#get-started","text":"Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization recommendations will be presented to you.","title":"Get started"},{"location":"readme/#paw-index-advisor","text":"Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"Paw Index Advisor"},{"location":"readme/#features_1","text":"Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if validation , make sure indexes recommended be used in later query execution","title":"Features"},{"location":"readme/#get-started_1","text":"Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter [ Paw Index Advisor ] in martketplace and click install Configure the running parameters of Paw Index Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for minutes and recommended indexes will be presented to you to accelerate your database queries. Claim: PawSQL Advisor and Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started"},{"location":"blog/","text":".md-sidebar--secondary:not([hidden]) { visibility: hidden; } Blog \u00b6 Four Pitfalls of SQL Processing with NULL Values \u00b6 NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic. In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7 In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you can will be able to cope with all the scenarios regarding to NULL value handling in your daily work. Continue reading Top 5 SQL Optimization Tools \u00b6 The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 10 5 read \u00b7 In this article, we evaluate five widely used SQL optimization tools, providing their cons and pros. Continue reading","title":"Blog"},{"location":"blog/#blog","text":"","title":"Blog"},{"location":"blog/#four-pitfalls-of-sql-processing-with-null-values","text":"NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic. In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7 In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you can will be able to cope with all the scenarios regarding to NULL value handling in your daily work. Continue reading","title":"Four Pitfalls of SQL Processing with NULL Values"},{"location":"blog/#top-5-sql-optimization-tools","text":"The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 10 5 read \u00b7 In this article, we evaluate five widely used SQL optimization tools, providing their cons and pros. Continue reading","title":"Top 5 SQL Optimization Tools"},{"location":"blog/2022/four_pitfalls_null_processing/","text":"Four Pitfalls of SQL Processing with NULL Values \u00b6 NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic . In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7 Overview \u00b6 In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you will be able to cope with all the scenarios regarding to NULL value handling in your daily work. Code of Examination \u00b6 The following examination logic covers all scenarios for NULL values in SQL processing, and by understanding the following logic, you can avoid the NULL pitfalls. The result of all comparison and arithmetic operators ( >, =, <, <>, <=, >=, +,-,*, / ) with NULL result is unknown The logical operations( AND, OR, NOT ) of unknown follows the truth values table of three-valued operations If the result of the operation is returned directly to the user, use NULL to represent unknown If the result of the operation is true or false as a condition during SQL processing, then the operation needs to be performed by the three-value logic, and the final result is determined by the following logic 4.1. {false\u3001unknown} -> false 4.2. {true} ->true In set operations such as UNION or INTERSECT , NULL values are considered equal to each other. Three-valued Logic 1 \u00b6 In logic, a three-valued logic (also trinary logic, trivalent, ternary, or trilean, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value. This is contrasted with the more commonly known bivalent logics (such as classical sentential or Boolean logic) which provide only for true and false. pitfalls of NULL Values \u00b6 Comparison with NULL Values \u00b6 Conclusion : expr = null can\u2019t determine the expression expr to be null , and is null should be used to determine whether the expr is null. Suppose there is a customer table with following five columns, among which two columns ( c_nationcode , c_phone ) are nullable. CREATE TABLE customer ( c_custkey int4 NOT NULL , c_name varchar ( 25 ) NOT NULL , c_nationcode char ( 8 ) NULL , c_phone varchar ( 15 ) NULL , c_regdate date NULL , CONSTRAINT customer_pkey PRIMARY KEY ( c_custkey ) ); insert into customer values ( 1 , 'Randy' , 'en' , '13910010010' , '20210911' ); insert into customer values ( 2 , 'Mandy' , null , '13910010012' , '20200211' ); insert into customer values ( 3 , 'Ray' , 'us' , null , '20180902' ); If a developer wants to find out the customers with empty phones through the following statement, he won't succeed because the result of following statement is always empty. select * from customer where c_phone = null ; The correct way should be\uff1a select * from customer where c_phone is null ; Let's examine according to the Code of Examination , the predicate c_phone = null is evaluated to unknown ; then according to Rule 4.1, unknown is treated as false . c_phone = null -> unknown -> false ; 2. Case When expression with NULL \u00b6 Conclusion : case expr when null can't determine if the expression is null, the correct way is case when expr is null . Problems in the where or having clause are easier to detect and correct, while it is much more difficult to dectect null usages in case when expressions, either by human or by existing SQL auditing tools. For example, if we want to decode the nation code to nation name, and the code is null, we want to set nation name to China : select c_name , case c_nationcode when 'us' then 'USA' when 'cn' then 'China' when null then 'China' else 'Others' end from customer The above statement does not convert the country code to null to China . Because when null is actually an operation performed by an c_nationcode = null . The correct way to to do it should be: select c_name , case when c_nationcode = 'us' then 'USA' when c_nationcode = 'cn' then 'China' when c_nationcode is null then 'China' else 'Others' end from customer 3. NOT IN with NULL \u00b6 Conclusion A predicate of a not in subquery with nullable select elements will always be evaluated to false. Suppose we have an orders table where the customer id( o_custkey ) and order date( o_orderdate ) are nullable due to missing data. CREATE TABLE orders ( o_orderkey int4 NOT NULL , o_custkey int4 NULL , o_orderdate date NULL , CONSTRAINT orders_pkey PRIMARY KEY ( o_orderkey ) ); insert into orders values ( 1 , 1 , '2021-01-01' ); insert into orders values ( 2 , null , '2020-09-01' ); insert into orders values ( 3 , 3 , null ); Now we want to find customers without orders for marketing. The expected result is the customer whose c_custkey is 2 , and the query statement might look like this, select * from customer where c_custkey not in ( select o_custkey from orders ) In fact, the above query return nothing to us. The reason is that the o_custkey in the subquery has null values, and the processing logic of NOT IN is like this c_custkey not in ( 1 \uff0c 3 , null ) \u2192 c_custkey <> 1 and c_custkey <> 3 and c_custkey <> null \u2192 c_custkey <> 1 and c_custkey <> 3 and unknown \u2192 unknown -> false In fact, if there are null values in the result set of the subquery, the SQL will always return empty result set. There are two correct ways: Add a NOT NULL predicate to the subquery, that is select * from customer where c_custkey not in ( select o_custkey from orders where o_custkey is not null ) Rewrite the NOT IN subquery to the not exists subquery, that is select * from customer where not exists ( select o_custkey from orders where o_custkey = c_custkey ) Note : PawSQL Advisor adopts the first method to do rewrite optimization, but it is more powerful, PawSQL Advisor first determines whether the columns in the subquery may be empty, and if it is possible, it will recommend the rewritten SQL to the user. 4. ALL Subquery with NULL \u00b6 Conclusion : A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. Suppose we want to find out the orders which are wrongly registered after the user is revoked. One of solution is this following query statement. select * from customer where c_regdate > ALL ( select o_orderdate from orders where c_custkey = o_custkey ) Similar to NOT IN above, this sql does not return the expected result due to the presence of NULL in the result of the subquery. The ALL operation is actually performed by comparing it with the returned result set, and then performing the AND operation, and the final result is unknown . While unknown as a condition to be evaluated is, the result is false . There are two ways to correct it: Add a NOT NULL predicate to the subquery, select * from customer where c_regdate > all ( select o_orderdate from orders where o_orderdate is not null ) Rewrite expr > all to aggregate scalar subquery expr > (select max()...) 2 select * from customer where c_regdate > ( select max ( o_custkey ) from orders ) Note : PawSQL Advisor adopts the second way to rewrite optimization, because PawSQL Advisor can further optimize the performance of the second rewritten SQL by rewriting ('max/min subquery rewrite rule'). NULL Optimization in PawSQL Advisor \u00b6 PawSQL Advisor has three rewrite optimization rules for NULL processing, corresponding to the four cases above. RuleCode Rule Description UseEqual4NullRewrite expr = null or case expr when null can't determine whether the expr is null , is null should be used NotInNullableSubQueryRewrite A predicate of a not in subquery with nullable select elements will always be evaluated to false. AllQualifierSubQueryRewrite A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. PawSQL Advisor is more powerful, it will be based on whether the definition of a column in the DDL is nullable, and whether the operation on the column will produce nullable results, to determine whether the query column in the subquery is nullable, if it is possible to be empty, it will recommend the rewritten SQL to the user. Logic of NotInNullableSubQueryRewrite iterate parse tree of input query \uff0c retrieve all the NOT IN predicate for each NOT IN predicate { if the predicate is PredicateInValueSelect ( ` expr not in ( select ....) ` ){ check whether result set of subquery is nullable if no \uff0c return ; if yes \uff0c for each nullabe SELECT element ( rc ){ check whether there is a predicate ` rc is not null ` in the subquery if no \uff0c create a predicate ` rc is not null ` and combine with the conditions of WHERE clause in the sub query ; if yes \uff0c continue ; } } if the predicate is PredicateInValueList ( ` expr not in values ( 1 , 2 , null ) ` ) for each value in the value list if the value is NULL \uff0c delete it } Logic of checking whether result set of subquery is nullable isNullable ( SELECT expr ){ if ( expr is column of a table ) { if ( column is defined nullable ) return true ; else return true ; } else if ( expr is NULL ) { return true ; } else if ( expr is constant of variable ) { return false ; } else if ( expr is a combined expr ){ return ( arg1 || arg2 || ...); } else if ( expr is a function ) { if ( the function is one of ( \"SUM\" , \"Count\" , \"AVG\" )) return false ; else return isNullable ( arguements of the function ) } else if ( expr is SSQ ) { return isNullable ( SELECT expr of the SSQ ) } else { return true ; } } Examination of The PawSQL Advisor regarding to NULL processing \u00b6 Sever cases of NULL handling are demonstrated. The columns c_phone and c_nationkey in the customer table definition are nullable. -- Case 1: = null rewritten to is null select count ( * ) from customer where c_phone = null ; -- Case 2: case expr when null is rewritten to case when expr is null select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer where not c_phone = null ; -- Case 3: c_nationkey nullable, increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Case 4: c_nationkey nullable, so max(c_nationkey) is nullable, increasing the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Case 5: count()/sum() is never empty, so there is no need to rewrite it select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Case 6: c_name is not null, but c_nationkey nullable, so you need to increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); -- Case 7: c_nationkey is nullable, so it is rewritten as > (select min(c_nationkey) from customer) select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer ); PawSQL Advisor Output (Summary) \u00b6 /********************************************************************\\ * * * PawSQL Optimization Summary * * * * Powered by PawSQL(2021- ) * * * \\********************************************************************/ 1 . Optimization Summary - There are 7 query analyzed ; - There are 6 optimization rewrites for 6 queries ; - There are 9 violations of optimization rule against 6 queries ; - There are 1 indices recommended for 4 queries ; - There is 12 . 91 % performance improvement . 2 . Optimization Rule Violations - RuleUseEqual4Null : [ null . sql - stmt2 , null . sql - stmt1 ] - RuleAllQualifierSubQueryRewrite : [ null . sql - stmt7 ] - RuleNoCond4NonAggSelect : [ null . sql - stmt3 , null . sql - stmt6 , null . sql - stmt7 ] - RuleNotInNullableSubQueryRewrite : [ null . sql - stmt4 , null . sql - stmt3 , null . sql - stmt6 ] ... PawSQL Advisor Output (single SQL details) \u00b6 Case 1: = null rewritten to is null -- Original SQL select count ( * ) from customer where c_phone = null ; -- Rewritten SQL select count ( * ) from customer where customer . c_phone is null ; Case 2: case expr when null rewritten as case when expr is null -- Original SQL select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer ; -- Rewritten SQL select case when c_phone is null then 1 when c_phone = '139%' then 0 else - 1 end from customer ; Case 3: c_nationkey is nullable, add the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer where c_nationkey is not null ) Case 4: c_nationkey is nullable, so max(c_nationkey) is nullable, adding the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select max ( customer . c_nationkey ) from customer where c_nationkey is not null group by c_mktsegment ) Case 5: count(c_nationkey) is never empty, so there is no need to rewrite it. select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); Case 6: c_name is not empty, but c_nationkey is nullable, so the c_nationkey is not null condition needs to be added. -- Original SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer where customer . c_nationkey is not null ) Case 7: c_nationkey is nullable, so rewritten as > (select min(c_nationkey) from customer) -- Original SQL select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from customer where n_nationkey > ( select min ( c_nationkey ) from customer ) https://en.wikipedia.org/wiki/Three-valued_logic \u21a9 If expr < all or expr < = all , then rewrite it as expr < (select min() ...) \u21a9","title":"Four pitfalls of SQL Processing with NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#four-pitfalls-of-sql-processing-with-null-values","text":"NULL value processing is the most error-prone for database application developers, mainly because we are accustomed to using binary Boolean logic to think, while the database's processing logic for NULL values is three-valued logic . In fact, the most flawed component in the database optimizers is actually the logic related to NULL value processing. Even mature database software, such as DB2/Teradata, still has more than 20% of the bugs related NULL processing. Tomas Nemec \u00b7 @Tomas Aug 5, 2022 \u00b7 10 min read \u00b7","title":"Four Pitfalls of SQL Processing with NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#overview","text":"In this article, we analyze the root causes of the NULL value pitfalls, and concludes a simple and effective logic to infer the final result. At the same time, we explain the applicable conditions and solutions for the four common scenarios in daily development work; Finally, three optimization rules related to NULL value processing in PawSQL Advisor are introduced and evaluated by examples. After reading this article, you will be able to cope with all the scenarios regarding to NULL value handling in your daily work.","title":"Overview"},{"location":"blog/2022/four_pitfalls_null_processing/#code-of-examination","text":"The following examination logic covers all scenarios for NULL values in SQL processing, and by understanding the following logic, you can avoid the NULL pitfalls. The result of all comparison and arithmetic operators ( >, =, <, <>, <=, >=, +,-,*, / ) with NULL result is unknown The logical operations( AND, OR, NOT ) of unknown follows the truth values table of three-valued operations If the result of the operation is returned directly to the user, use NULL to represent unknown If the result of the operation is true or false as a condition during SQL processing, then the operation needs to be performed by the three-value logic, and the final result is determined by the following logic 4.1. {false\u3001unknown} -> false 4.2. {true} ->true In set operations such as UNION or INTERSECT , NULL values are considered equal to each other.","title":"Code of Examination"},{"location":"blog/2022/four_pitfalls_null_processing/#three-valued-logic1","text":"In logic, a three-valued logic (also trinary logic, trivalent, ternary, or trilean, sometimes abbreviated 3VL) is any of several many-valued logic systems in which there are three truth values indicating true, false and some indeterminate third value. This is contrasted with the more commonly known bivalent logics (such as classical sentential or Boolean logic) which provide only for true and false.","title":"Three-valued Logic1"},{"location":"blog/2022/four_pitfalls_null_processing/#pitfalls-of-null-values","text":"","title":"pitfalls of NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#comparison-with-null-values","text":"Conclusion : expr = null can\u2019t determine the expression expr to be null , and is null should be used to determine whether the expr is null. Suppose there is a customer table with following five columns, among which two columns ( c_nationcode , c_phone ) are nullable. CREATE TABLE customer ( c_custkey int4 NOT NULL , c_name varchar ( 25 ) NOT NULL , c_nationcode char ( 8 ) NULL , c_phone varchar ( 15 ) NULL , c_regdate date NULL , CONSTRAINT customer_pkey PRIMARY KEY ( c_custkey ) ); insert into customer values ( 1 , 'Randy' , 'en' , '13910010010' , '20210911' ); insert into customer values ( 2 , 'Mandy' , null , '13910010012' , '20200211' ); insert into customer values ( 3 , 'Ray' , 'us' , null , '20180902' ); If a developer wants to find out the customers with empty phones through the following statement, he won't succeed because the result of following statement is always empty. select * from customer where c_phone = null ; The correct way should be\uff1a select * from customer where c_phone is null ; Let's examine according to the Code of Examination , the predicate c_phone = null is evaluated to unknown ; then according to Rule 4.1, unknown is treated as false . c_phone = null -> unknown -> false ;","title":"Comparison with NULL Values"},{"location":"blog/2022/four_pitfalls_null_processing/#2-case-when-expression-with-null","text":"Conclusion : case expr when null can't determine if the expression is null, the correct way is case when expr is null . Problems in the where or having clause are easier to detect and correct, while it is much more difficult to dectect null usages in case when expressions, either by human or by existing SQL auditing tools. For example, if we want to decode the nation code to nation name, and the code is null, we want to set nation name to China : select c_name , case c_nationcode when 'us' then 'USA' when 'cn' then 'China' when null then 'China' else 'Others' end from customer The above statement does not convert the country code to null to China . Because when null is actually an operation performed by an c_nationcode = null . The correct way to to do it should be: select c_name , case when c_nationcode = 'us' then 'USA' when c_nationcode = 'cn' then 'China' when c_nationcode is null then 'China' else 'Others' end from customer","title":"2. Case When expression with NULL"},{"location":"blog/2022/four_pitfalls_null_processing/#3-not-in-with-null","text":"Conclusion A predicate of a not in subquery with nullable select elements will always be evaluated to false. Suppose we have an orders table where the customer id( o_custkey ) and order date( o_orderdate ) are nullable due to missing data. CREATE TABLE orders ( o_orderkey int4 NOT NULL , o_custkey int4 NULL , o_orderdate date NULL , CONSTRAINT orders_pkey PRIMARY KEY ( o_orderkey ) ); insert into orders values ( 1 , 1 , '2021-01-01' ); insert into orders values ( 2 , null , '2020-09-01' ); insert into orders values ( 3 , 3 , null ); Now we want to find customers without orders for marketing. The expected result is the customer whose c_custkey is 2 , and the query statement might look like this, select * from customer where c_custkey not in ( select o_custkey from orders ) In fact, the above query return nothing to us. The reason is that the o_custkey in the subquery has null values, and the processing logic of NOT IN is like this c_custkey not in ( 1 \uff0c 3 , null ) \u2192 c_custkey <> 1 and c_custkey <> 3 and c_custkey <> null \u2192 c_custkey <> 1 and c_custkey <> 3 and unknown \u2192 unknown -> false In fact, if there are null values in the result set of the subquery, the SQL will always return empty result set. There are two correct ways: Add a NOT NULL predicate to the subquery, that is select * from customer where c_custkey not in ( select o_custkey from orders where o_custkey is not null ) Rewrite the NOT IN subquery to the not exists subquery, that is select * from customer where not exists ( select o_custkey from orders where o_custkey = c_custkey ) Note : PawSQL Advisor adopts the first method to do rewrite optimization, but it is more powerful, PawSQL Advisor first determines whether the columns in the subquery may be empty, and if it is possible, it will recommend the rewritten SQL to the user.","title":"3. NOT IN with NULL"},{"location":"blog/2022/four_pitfalls_null_processing/#4-all-subquery-with-null","text":"Conclusion : A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. Suppose we want to find out the orders which are wrongly registered after the user is revoked. One of solution is this following query statement. select * from customer where c_regdate > ALL ( select o_orderdate from orders where c_custkey = o_custkey ) Similar to NOT IN above, this sql does not return the expected result due to the presence of NULL in the result of the subquery. The ALL operation is actually performed by comparing it with the returned result set, and then performing the AND operation, and the final result is unknown . While unknown as a condition to be evaluated is, the result is false . There are two ways to correct it: Add a NOT NULL predicate to the subquery, select * from customer where c_regdate > all ( select o_orderdate from orders where o_orderdate is not null ) Rewrite expr > all to aggregate scalar subquery expr > (select max()...) 2 select * from customer where c_regdate > ( select max ( o_custkey ) from orders ) Note : PawSQL Advisor adopts the second way to rewrite optimization, because PawSQL Advisor can further optimize the performance of the second rewritten SQL by rewriting ('max/min subquery rewrite rule').","title":"4. ALL Subquery with NULL"},{"location":"blog/2022/four_pitfalls_null_processing/#null-optimization-in-pawsql-advisor","text":"PawSQL Advisor has three rewrite optimization rules for NULL processing, corresponding to the four cases above. RuleCode Rule Description UseEqual4NullRewrite expr = null or case expr when null can't determine whether the expr is null , is null should be used NotInNullableSubQueryRewrite A predicate of a not in subquery with nullable select elements will always be evaluated to false. AllQualifierSubQueryRewrite A condition of an ALL -qualified subquery with nullable select elements will always be evaluated to false. PawSQL Advisor is more powerful, it will be based on whether the definition of a column in the DDL is nullable, and whether the operation on the column will produce nullable results, to determine whether the query column in the subquery is nullable, if it is possible to be empty, it will recommend the rewritten SQL to the user. Logic of NotInNullableSubQueryRewrite iterate parse tree of input query \uff0c retrieve all the NOT IN predicate for each NOT IN predicate { if the predicate is PredicateInValueSelect ( ` expr not in ( select ....) ` ){ check whether result set of subquery is nullable if no \uff0c return ; if yes \uff0c for each nullabe SELECT element ( rc ){ check whether there is a predicate ` rc is not null ` in the subquery if no \uff0c create a predicate ` rc is not null ` and combine with the conditions of WHERE clause in the sub query ; if yes \uff0c continue ; } } if the predicate is PredicateInValueList ( ` expr not in values ( 1 , 2 , null ) ` ) for each value in the value list if the value is NULL \uff0c delete it } Logic of checking whether result set of subquery is nullable isNullable ( SELECT expr ){ if ( expr is column of a table ) { if ( column is defined nullable ) return true ; else return true ; } else if ( expr is NULL ) { return true ; } else if ( expr is constant of variable ) { return false ; } else if ( expr is a combined expr ){ return ( arg1 || arg2 || ...); } else if ( expr is a function ) { if ( the function is one of ( \"SUM\" , \"Count\" , \"AVG\" )) return false ; else return isNullable ( arguements of the function ) } else if ( expr is SSQ ) { return isNullable ( SELECT expr of the SSQ ) } else { return true ; } }","title":"NULL Optimization in PawSQL Advisor"},{"location":"blog/2022/four_pitfalls_null_processing/#examination-of-the-pawsql-advisor-regarding-to-null-processing","text":"Sever cases of NULL handling are demonstrated. The columns c_phone and c_nationkey in the customer table definition are nullable. -- Case 1: = null rewritten to is null select count ( * ) from customer where c_phone = null ; -- Case 2: case expr when null is rewritten to case when expr is null select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer where not c_phone = null ; -- Case 3: c_nationkey nullable, increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Case 4: c_nationkey nullable, so max(c_nationkey) is nullable, increasing the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Case 5: count()/sum() is never empty, so there is no need to rewrite it select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Case 6: c_name is not null, but c_nationkey nullable, so you need to increase the c_nationkey is not null condition select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); -- Case 7: c_nationkey is nullable, so it is rewritten as > (select min(c_nationkey) from customer) select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer );","title":"Examination of The PawSQL Advisor regarding to NULL processing"},{"location":"blog/2022/four_pitfalls_null_processing/#pawsql-advisor-output-summary","text":"/********************************************************************\\ * * * PawSQL Optimization Summary * * * * Powered by PawSQL(2021- ) * * * \\********************************************************************/ 1 . Optimization Summary - There are 7 query analyzed ; - There are 6 optimization rewrites for 6 queries ; - There are 9 violations of optimization rule against 6 queries ; - There are 1 indices recommended for 4 queries ; - There is 12 . 91 % performance improvement . 2 . Optimization Rule Violations - RuleUseEqual4Null : [ null . sql - stmt2 , null . sql - stmt1 ] - RuleAllQualifierSubQueryRewrite : [ null . sql - stmt7 ] - RuleNoCond4NonAggSelect : [ null . sql - stmt3 , null . sql - stmt6 , null . sql - stmt7 ] - RuleNotInNullableSubQueryRewrite : [ null . sql - stmt4 , null . sql - stmt3 , null . sql - stmt6 ] ...","title":"PawSQL Advisor Output (Summary)"},{"location":"blog/2022/four_pitfalls_null_processing/#pawsql-advisor-output-single-sql-details","text":"Case 1: = null rewritten to is null -- Original SQL select count ( * ) from customer where c_phone = null ; -- Rewritten SQL select count ( * ) from customer where customer . c_phone is null ; Case 2: case expr when null rewritten as case when expr is null -- Original SQL select case c_phone when null then 1 when '139%' then 0 else - 1 end from customer ; -- Rewritten SQL select case when c_phone is null then 1 when c_phone = '139%' then 0 else - 1 end from customer ; Case 3: c_nationkey is nullable, add the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select c_nationkey from customer where c_nationkey is not null ) Case 4: c_nationkey is nullable, so max(c_nationkey) is nullable, adding the condition c_nationkey is not null -- Original SQL select count ( * ) from nation where n_nationkey not in ( select max ( c_nationkey ) from customer group by c_mktsegment ); -- Rewritten SQL select count ( * ) from nation where n_nationkey not in ( select max ( customer . c_nationkey ) from customer where c_nationkey is not null group by c_mktsegment ) Case 5: count(c_nationkey) is never empty, so there is no need to rewrite it. select count ( * ) from nation where n_nationkey not in ( select count ( c_nationkey ) from customer group by c_mktsegment ); Case 6: c_name is not empty, but c_nationkey is nullable, so the c_nationkey is not null condition needs to be added. -- Original SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer ); -- Rewritten SQL select count ( * ) from nation where ( n_name , n_nationkey ) not in ( select 'China' , c_nationkey from customer where customer . c_nationkey is not null ) Case 7: c_nationkey is nullable, so rewritten as > (select min(c_nationkey) from customer) -- Original SQL select count ( * ) from customer where n_nationkey > all ( select c_nationkey from customer ); -- Rewritten SQL select count ( * ) from customer where n_nationkey > ( select min ( c_nationkey ) from customer ) https://en.wikipedia.org/wiki/Three-valued_logic \u21a9 If expr < all or expr < = all , then rewrite it as expr < (select min() ...) \u21a9","title":"PawSQL Advisor Output (single SQL details)"},{"location":"blog/2022/top5_sql_optimization_tools/","text":"Top 5 SQL Optimization Tools \u00b6 The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. ![ @pawsql ][ @pawsql avatar] Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 5 min read\u00b7 List of the top 5 SQL optimization tools \u00b6 SolarWinds Database Performance Analyzer Toad SQL Optimizer for Oracle EverSQL Query Optimizer PawSQL Advisor SQL tuning Here are the details on the pros and cons of each tool: SolarWinds Database Performance Analyzer \u00b6 Pros: Azure SQL databases, MySQL, Aurora, ASE, Oracle, MariaDB, and IBM Db2 supported Full-featured SQL query optimization tool On-going Performance insights Configuration tunning Cons: Weak query tuning More like finding the performance problems instead of solving them. Price: 14-day free trial , starts at $1,995 Toad SQL Optimizer for Oracle \u00b6 Pros: a part of an excellent suite for DBAs Query execution plan visualization Identify slow queries Inspect System Global Area (SGA) Cons: Only Oracle supported Designed for DBAs, too complicated for engineers without DBA skills Requires local installation Price: 14-days Free trial, Starts at $1,164 EverSQL ** \u00b6 Pros: Automatic SQL rewrite Supports MySQL, PostgreSQL, MariaDB, Percona, SQL Server, Cloud SQL, Aurora No installation required Missing indexes recommendations Machine learning algorithms On-going Performance insights Friendly for Software Developers Cons: Recommendations are not verified; the example rewrite is no good for performance. Some indexes recommended are not used. Price: Free for basic usage , one optimization a month. Advanced edition starts at $75. PawSQL Advisor \u00b6 Pros: Rules-based SQL auditing Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Powerful and intelligent index recommendation What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Cons: Only available as a plugin on Intellij based tools, such as IntelliJ IDEA, CLion, PyCharm Only support MySQL, PostgreSQL and derivatives, such as Opengauss, Maria Price: Free for now, no pricing policy announced SQL tuning \u00b6 Pros: On-line, no installation required Cons: Only Oracle support The software is sometimes buggy, some users report non-relevant recommendations Very basic, provides general recommendations Doesn't offer rewritten query Price: Free","title":"Top 5 SQL Optimization Tools"},{"location":"blog/2022/top5_sql_optimization_tools/#top-5-sql-optimization-tools","text":"The Structured Query Language has become the most used query language and it is supported by most modern relational database management systems. There are many ways to write a query to get the same result in SQL but the performance may differ significantly. SQL optimization tools help developers or database administrators to determine the best way to execute a query with the best performance. ![ @pawsql ][ @pawsql avatar] Paw SQL \u00b7 @pawsql Aug 26, 2022 \u00b7 5 min read\u00b7","title":"Top 5 SQL Optimization Tools"},{"location":"blog/2022/top5_sql_optimization_tools/#list-of-the-top-5-sql-optimization-tools","text":"SolarWinds Database Performance Analyzer Toad SQL Optimizer for Oracle EverSQL Query Optimizer PawSQL Advisor SQL tuning Here are the details on the pros and cons of each tool:","title":"List of the top 5 SQL optimization tools"},{"location":"blog/2022/top5_sql_optimization_tools/#solarwinds-database-performance-analyzer","text":"Pros: Azure SQL databases, MySQL, Aurora, ASE, Oracle, MariaDB, and IBM Db2 supported Full-featured SQL query optimization tool On-going Performance insights Configuration tunning Cons: Weak query tuning More like finding the performance problems instead of solving them. Price: 14-day free trial , starts at $1,995","title":"SolarWinds Database Performance Analyzer"},{"location":"blog/2022/top5_sql_optimization_tools/#toad-sql-optimizer-for-oracle","text":"Pros: a part of an excellent suite for DBAs Query execution plan visualization Identify slow queries Inspect System Global Area (SGA) Cons: Only Oracle supported Designed for DBAs, too complicated for engineers without DBA skills Requires local installation Price: 14-days Free trial, Starts at $1,164","title":"Toad SQL Optimizer for Oracle"},{"location":"blog/2022/top5_sql_optimization_tools/#eversql","text":"Pros: Automatic SQL rewrite Supports MySQL, PostgreSQL, MariaDB, Percona, SQL Server, Cloud SQL, Aurora No installation required Missing indexes recommendations Machine learning algorithms On-going Performance insights Friendly for Software Developers Cons: Recommendations are not verified; the example rewrite is no good for performance. Some indexes recommended are not used. Price: Free for basic usage , one optimization a month. Advanced edition starts at $75.","title":"EverSQL**"},{"location":"blog/2022/top5_sql_optimization_tools/#pawsql-advisor","text":"Pros: Rules-based SQL auditing Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Powerful and intelligent index recommendation What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Cons: Only available as a plugin on Intellij based tools, such as IntelliJ IDEA, CLion, PyCharm Only support MySQL, PostgreSQL and derivatives, such as Opengauss, Maria Price: Free for now, no pricing policy announced","title":"PawSQL  Advisor"},{"location":"blog/2022/top5_sql_optimization_tools/#sql-tuning","text":"Pros: On-line, no installation required Cons: Only Oracle support The software is sometimes buggy, some users report non-relevant recommendations Very basic, provides general recommendations Doesn't offer rewritten query Price: Free","title":"SQL tuning"},{"location":"pawindexadvisor/","text":"What is Paw Index Advisor? \u00b6 Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if analysis , make sure indexes recommended be used in later query execution Get started \u00b6 Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter \"Paw Index Advisor\" in martketplace and click install Configure the running parameters of PawSQL Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for a minute and recommended indexes will be presented to you to accelerate your database queries. Claim: Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started with Paw Index Advisor"},{"location":"pawindexadvisor/#what-is-paw-index-advisor","text":"Paw Index Advisor is an automatic and intelligent cost-based index recommendation tool for MySQL and PostgreSQL databases. Paw Index Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"What is Paw Index Advisor?"},{"location":"pawindexadvisor/#features","text":"Combination of cost based and heuristic algorithm based Support MySQL and PostgreSQL and derivatives, such as Opengauss, Maria Support index recommendation covering matching, screening, sort-avoiding,covering De-duplicate with existing indexes Support query rewrites, sattc, view folding, and ordinal rewrite Client-based, non-invasion to production system Support what-if analysis , make sure indexes recommended be used in later query execution","title":"Features"},{"location":"pawindexadvisor/#get-started","text":"Start the JetBrains IDE(IntelliJ IDEA, CLion, PyCharm and etc), open the project Setting, select Plugins; Enter \"Paw Index Advisor\" in martketplace and click install Configure the running parameters of PawSQL Advisor on the Setting page Right click on the SQL file or folder to be analyzed, and click \"Run Index Advisor\" Wait for a minute and recommended indexes will be presented to you to accelerate your database queries. Claim: Paw Index Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started"},{"location":"pawindexadvisor/change-log/","text":"Changelog \u00b6 0.1.109 _ August 15, 2022 \u00b6 Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue. 0.1.108 _ August 10, 2022 \u00b6 Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12. 0.1.106 _ August 10, 2022 \u00b6 Initial beta release.","title":"Change Log"},{"location":"pawindexadvisor/change-log/#changelog","text":"","title":"Changelog"},{"location":"pawindexadvisor/change-log/#0.1.109","text":"Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue.","title":"0.1.109 _ August 15, 2022"},{"location":"pawindexadvisor/change-log/#0.1.108","text":"Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12.","title":"0.1.108 _ August 10, 2022"},{"location":"pawindexadvisor/change-log/#0.1.106","text":"Initial beta release.","title":"0.1.106 _ August 10, 2022"},{"location":"pawindexadvisor/command-line/","text":"Command Line \u00b6 For database administrators, they can use Paw Index Advisor in a command line way, which gives the user more control how the tool behave, comparing with the plugin way. Prerequisites \u00b6 JRE 1.8 or above OS: Windows + Linux+Mac OS Command \u00b6 $ java -jar paw-indexadvisor.jar -c config/config.properties Configuration \u00b6 The input and parameters needed for Paw Index Advisor to work are defined in the configuration file config/config.properties . config.properties \u00b6 # The configuration file for index advisor # config the workload sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases sqllab.mapperfolder = ./tpch/mappers # config the ddl sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ sqllab.statsmode = offline sqllab.statsfolder = ./tpch/stats # server info for online retrieve dbobjects/stats and for what-if analysis sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch # config the output directory sqllab.resultfolder = ./tpch/out/index.sql # whether de-duplicate with existing indexes sqllab.ia.dedupflag = true # whether what-if validation sqllab.ia.validate = true","title":"Command Line"},{"location":"pawindexadvisor/command-line/#command-line","text":"For database administrators, they can use Paw Index Advisor in a command line way, which gives the user more control how the tool behave, comparing with the plugin way.","title":"Command Line"},{"location":"pawindexadvisor/command-line/#prerequisites","text":"JRE 1.8 or above OS: Windows + Linux+Mac OS","title":"Prerequisites"},{"location":"pawindexadvisor/command-line/#command","text":"$ java -jar paw-indexadvisor.jar -c config/config.properties","title":"Command"},{"location":"pawindexadvisor/command-line/#configuration","text":"The input and parameters needed for Paw Index Advisor to work are defined in the configuration file config/config.properties .","title":"Configuration"},{"location":"pawindexadvisor/command-line/#configproperties","text":"# The configuration file for index advisor # config the workload sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases sqllab.mapperfolder = ./tpch/mappers # config the ddl sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ sqllab.statsmode = offline sqllab.statsfolder = ./tpch/stats # server info for online retrieve dbobjects/stats and for what-if analysis sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch # config the output directory sqllab.resultfolder = ./tpch/out/index.sql # whether de-duplicate with existing indexes sqllab.ia.dedupflag = true # whether what-if validation sqllab.ia.validate = true","title":"config.properties"},{"location":"pawindexadvisor/configuration/","text":"Configuration \u00b6 You can configure and control the execution process on the Paw Index Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation Query Type \u00b6 Specifies the type of input SQL statements. Paw Index Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, Paw Index Advisor will parse those file and permutes all possible SQL combinations. Paw Index Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some of the combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog. Database Vendor \u00b6 Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested. Connection Info \u00b6 Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance. Database host \u00b6 Ip address or host name of the database server Database port \u00b6 Port of the connection to the database server User \u00b6 User name to connect to the database server Password \u00b6 The password of the user connecting to the database server DefaultDB \u00b6 The default database name when connecting to the database server Database/schema List \u00b6 For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b Deduplicate with existing indexes \u00b6 If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index. What-if analysis validation \u00b6 If this option is checked, Paw Index Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), Paw Index Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"Configuration"},{"location":"pawindexadvisor/configuration/#configuration","text":"You can configure and control the execution process on the Paw Index Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation","title":"Configuration"},{"location":"pawindexadvisor/configuration/#query-type","text":"Specifies the type of input SQL statements. Paw Index Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, Paw Index Advisor will parse those file and permutes all possible SQL combinations. Paw Index Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some of the combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog.","title":"Query Type"},{"location":"pawindexadvisor/configuration/#database-vendor","text":"Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested.","title":"Database Vendor"},{"location":"pawindexadvisor/configuration/#connection-info","text":"Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance.","title":"Connection Info"},{"location":"pawindexadvisor/configuration/#database-host","text":"Ip address or host name of the database server","title":"Database host"},{"location":"pawindexadvisor/configuration/#database-port","text":"Port of the connection to the database server","title":"Database port"},{"location":"pawindexadvisor/configuration/#user","text":"User name to connect to the database server","title":"User"},{"location":"pawindexadvisor/configuration/#password","text":"The password of the user connecting to the database server","title":"Password"},{"location":"pawindexadvisor/configuration/#defaultdb","text":"The default database name when connecting to the database server","title":"DefaultDB"},{"location":"pawindexadvisor/configuration/#databaseschema-list","text":"For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b","title":"Database/schema List"},{"location":"pawindexadvisor/configuration/#deduplicate-with-existing-indexes","text":"If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index.","title":"Deduplicate with existing indexes"},{"location":"pawindexadvisor/configuration/#what-if-analysis-validation","text":"If this option is checked, Paw Index Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), Paw Index Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"What-if analysis validation"},{"location":"pawindexadvisor/configuration2/","text":"Configuration \u00b6 You can configure the input, output and control the execution process either in config.properties file in the command line mode, or on the Configuration page when you are using the Paw Index Advisor plugin. Configure Db-objects \u00b6 The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names in the SQL statements to be optimized, and they will be use in following query rewrite optimization and index recommendation. Command Line IntelliJ Plugin Property sqllab.ddlmode is used to define how and what database objects(relation table definitions and indexes definitions) are use for the Paw Index Advisor to execute against. If offline mode is set\uff0c sqllab.ddlfolder should be specified to define which directory should be look up within. sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ If online mode is set\uff0c sqllab.server parameters should be specified, MySQL and PostgreSQL and derivatives, such as opengauss, maria are supported\u3002 sqllab.ddlmode = online sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch There is only the online option if your use Paw Index Advisor plugin, and you need to fill sql.server fields Configure Queries \u00b6 The next step is to specify the input queries to optimize. Command Line IntelliJ Plugin Property sqllab.querymode is used to define how and what query statements to be analyzed and optimized. When offline mode is set\uff0c sqllab.queryfolder should be specified to define which directory should be looked within. sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases When mapper mode is set\uff0c\uff0c sqllab.mapperfolder should be specified sqllab.querymode = mapper sqllab.mapperfolder = ./tpch/mappers If you are using Paw Index Advisor plugin, the input queries to optimize is the sql file you right clicked on or the sql files under the directory you right clicked on in the IDEA on which the Paw Index Advisor plugin is installed. Configure Output \u00b6 There are two result files generated, %paw_index.sql and %paw_index_what_if.txt . You can specify where they will be placed into. Command Line IntelliJ Plugin Property sqllab.resultfolder is used to specify which directory the recommended indexes will be placed into. And the validation details will be under the same directory with a name postfixed with what-if . sqllab.resultfolder = ./tpch/out/index.sql If you are using Paw Index Advisor plugin, you needn't to specify the output directory. If you analyze a sql file named filename.sql , the output files will be filename_paw_index.sql and filename_paw_index_what_if.txt under the same directory. If you analyze sql files under a directory directoryname , the output files will be paw_index.sql and paw_index_what_if.txt under the directory directoryname . Configure Execution \u00b6 You can control the execution process by configure execution parameters. De-duplicate with existing indexes \u00b6 If this parameter is set to true, the Paw Index Advisor will de-duplicate the candidate indexes with existing indexes. The process will adhere to the leftmost matching rule. Command Line IntelliJ Plugin sqllab.ia.dedupflag = true Check the check-box in the Index Advisor Configuration page. What-if validation \u00b6 If this parameter is set to true, the database connection information must be set correctly. The Paw Index Advisor will do an extra what-if validation phase against database and only indexes which contribute the performance improvement will be recommended. Command Line IntelliJ Plugin sqllab.ia.validate = true Check the check-box in the Index Advisor Configuration page.","title":"Configuration"},{"location":"pawindexadvisor/configuration2/#configuration","text":"You can configure the input, output and control the execution process either in config.properties file in the command line mode, or on the Configuration page when you are using the Paw Index Advisor plugin.","title":"Configuration"},{"location":"pawindexadvisor/configuration2/#configure-db-objects","text":"The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names in the SQL statements to be optimized, and they will be use in following query rewrite optimization and index recommendation. Command Line IntelliJ Plugin Property sqllab.ddlmode is used to define how and what database objects(relation table definitions and indexes definitions) are use for the Paw Index Advisor to execute against. If offline mode is set\uff0c sqllab.ddlfolder should be specified to define which directory should be look up within. sqllab.ddlmode = offline sqllab.ddlfolder = ./tpch/ddl/ If online mode is set\uff0c sqllab.server parameters should be specified, MySQL and PostgreSQL and derivatives, such as opengauss, maria are supported\u3002 sqllab.ddlmode = online sqllab.server.type = mysql sqllab.server.host = localhost sqllab.server.username = root sqllab.server.password = root sqllab.databaselist = tpch There is only the online option if your use Paw Index Advisor plugin, and you need to fill sql.server fields","title":"Configure Db-objects"},{"location":"pawindexadvisor/configuration2/#configure-queries","text":"The next step is to specify the input queries to optimize. Command Line IntelliJ Plugin Property sqllab.querymode is used to define how and what query statements to be analyzed and optimized. When offline mode is set\uff0c sqllab.queryfolder should be specified to define which directory should be looked within. sqllab.querymode = offline sqllab.queryfolder = ./tpch/cases When mapper mode is set\uff0c\uff0c sqllab.mapperfolder should be specified sqllab.querymode = mapper sqllab.mapperfolder = ./tpch/mappers If you are using Paw Index Advisor plugin, the input queries to optimize is the sql file you right clicked on or the sql files under the directory you right clicked on in the IDEA on which the Paw Index Advisor plugin is installed.","title":"Configure Queries"},{"location":"pawindexadvisor/configuration2/#configure-output","text":"There are two result files generated, %paw_index.sql and %paw_index_what_if.txt . You can specify where they will be placed into. Command Line IntelliJ Plugin Property sqllab.resultfolder is used to specify which directory the recommended indexes will be placed into. And the validation details will be under the same directory with a name postfixed with what-if . sqllab.resultfolder = ./tpch/out/index.sql If you are using Paw Index Advisor plugin, you needn't to specify the output directory. If you analyze a sql file named filename.sql , the output files will be filename_paw_index.sql and filename_paw_index_what_if.txt under the same directory. If you analyze sql files under a directory directoryname , the output files will be paw_index.sql and paw_index_what_if.txt under the directory directoryname .","title":"Configure Output"},{"location":"pawindexadvisor/configuration2/#configure-execution","text":"You can control the execution process by configure execution parameters.","title":"Configure Execution"},{"location":"pawindexadvisor/configuration2/#de-duplicate-with-existing-indexes","text":"If this parameter is set to true, the Paw Index Advisor will de-duplicate the candidate indexes with existing indexes. The process will adhere to the leftmost matching rule. Command Line IntelliJ Plugin sqllab.ia.dedupflag = true Check the check-box in the Index Advisor Configuration page.","title":"De-duplicate with existing indexes"},{"location":"pawindexadvisor/configuration2/#what-if-validation","text":"If this parameter is set to true, the database connection information must be set correctly. The Paw Index Advisor will do an extra what-if validation phase against database and only indexes which contribute the performance improvement will be recommended. Command Line IntelliJ Plugin sqllab.ia.validate = true Check the check-box in the Index Advisor Configuration page.","title":"What-if validation"},{"location":"pawindexadvisor/eula/","text":"End-User License Agreement (EULA) of Paw Index Advisor \u00b6 This EULA agreement governs your acquisition and use of our Paw Index Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the Paw Index Advisor software. It provides a license to use the Paw Index Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the Paw Index Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Paw Index Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant \u00b6 Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the Paw Index Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Paw Index Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Paw Index Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement Intellectual Property and Ownership \u00b6 Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties. Termination \u00b6 This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL. Governing Law \u00b6 This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"EULA"},{"location":"pawindexadvisor/eula/#end-user-license-agreement-eula-of-paw-index-advisor","text":"This EULA agreement governs your acquisition and use of our Paw Index Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the Paw Index Advisor software. It provides a license to use the Paw Index Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the Paw Index Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the Paw Index Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of Paw Index Advisor"},{"location":"pawindexadvisor/eula/#license-grant","text":"Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the Paw Index Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the Paw Index Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the Paw Index Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement","title":"License Grant"},{"location":"pawindexadvisor/eula/#intellectual-property-and-ownership","text":"Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"pawindexadvisor/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL.","title":"Termination"},{"location":"pawindexadvisor/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"Governing Law"},{"location":"pawindexadvisor/intellij-plugin/","text":"IntelliJ Plugin \u00b6 Paw Index Advisor is integrated into most popular IDEs, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm and Eclipse, Spring Tool Suite. For application developers, they can optimize the application performance by One Click . Steps: Install a compatible JetBrains IDE, such as IntelliJ IDEA, CLion, PyCharm, or other IntelliJ-based IDEs. Launch the IDE and open plugin settings Search for \"Paw Index Advisor\" in martketplace and click install Configure the query type and database information on the configuration page Right click any folder which contains the sql statments/mybatis xml files, and click \"Run Index Advisor\" Wait for a minute and indexes are recommended to accelerate your database queries. Installation \u00b6 Method 1: Search for \"Paw Index Advisor\" in marketplace and click install( Prefer ). Method 2: you can visit the \"Paw Index Advisor\" plugin page at https://plugins.jetbrains.com/plugin/19003-paw-index-advisor , and install it from that page or download the plugin and install it from disk later. Configuration \u00b6 Configure the input and execution parameters in the Project Setting panel. See details at Configure the Index Advisor Run by One Click \u00b6 Right click on a SQL/mybatis xml file or any folder which contains the sql statements/mybatis xml files, and click \"Run Index Advisor\". You can see the analysis is started on the PawSQL console. Get recommendation \u00b6 After the analysis is done, the recommendation result file named paw_index.sql is opened for you, and you can also find the validation details in the paw_index_what-if.txt file. You can decided whether to apply those recommendation according to the validation details of queries. You can find the details about how to interpret the output at Explain the Output .","title":"IntelliJ Plugin"},{"location":"pawindexadvisor/intellij-plugin/#intellij-plugin","text":"Paw Index Advisor is integrated into most popular IDEs, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm and Eclipse, Spring Tool Suite. For application developers, they can optimize the application performance by One Click . Steps: Install a compatible JetBrains IDE, such as IntelliJ IDEA, CLion, PyCharm, or other IntelliJ-based IDEs. Launch the IDE and open plugin settings Search for \"Paw Index Advisor\" in martketplace and click install Configure the query type and database information on the configuration page Right click any folder which contains the sql statments/mybatis xml files, and click \"Run Index Advisor\" Wait for a minute and indexes are recommended to accelerate your database queries.","title":"IntelliJ Plugin"},{"location":"pawindexadvisor/intellij-plugin/#installation","text":"Method 1: Search for \"Paw Index Advisor\" in marketplace and click install( Prefer ). Method 2: you can visit the \"Paw Index Advisor\" plugin page at https://plugins.jetbrains.com/plugin/19003-paw-index-advisor , and install it from that page or download the plugin and install it from disk later.","title":"Installation"},{"location":"pawindexadvisor/intellij-plugin/#configuration","text":"Configure the input and execution parameters in the Project Setting panel. See details at Configure the Index Advisor","title":"Configuration"},{"location":"pawindexadvisor/intellij-plugin/#run-by-one-click","text":"Right click on a SQL/mybatis xml file or any folder which contains the sql statements/mybatis xml files, and click \"Run Index Advisor\". You can see the analysis is started on the PawSQL console.","title":"Run by One Click"},{"location":"pawindexadvisor/intellij-plugin/#get-recommendation","text":"After the analysis is done, the recommendation result file named paw_index.sql is opened for you, and you can also find the validation details in the paw_index_what-if.txt file. You can decided whether to apply those recommendation according to the validation details of queries. You can find the details about how to interpret the output at Explain the Output .","title":"Get recommendation"},{"location":"pawindexadvisor/recommended-indexes/","text":"Indexes Recommended \u00b6 After the recommending indexes process is done, there will be two result files generated in the directory of optimized input queries, one is the summary file paw_index.sql and the other is the validation details file paw_index_what_if.txt , outlined as follows: . \u2514\u2500 file1.sql \u2514\u2500 file2.sql \u2514\u2500 paw_index.sql \u2514\u2500 paw_index_what_if.txt Recommendation Summary \u00b6 The summary file paw_index.sql contains following three section of inforamtion Existing Indexes \u00b6 This section contains the existing indexes of tables referenced in the input SQL queries. Those tables may not used in the query execution and can be dropped later. -- Existing indexes CREATE INDEX CUSTOMER_C_NATIONKEY_FKEY ON CUSTOMER ( C_NATIONKEY ); CREATE INDEX CUSTOMER_PKEY ON CUSTOMER ( C_CUSTKEY ); CREATE INDEX MYINDEX ON CUSTOMER ( C_NAME , C_PHONE ); CREATE INDEX LINEITEM_L_ORDERKEY_FKEY ON LINEITEM ( L_ORDERKEY ); CREATE INDEX LINEITEM_L_PARTKEY_L_SUPPKEY_FKEY ON LINEITEM ( L_SUPPKEY , L_PARTKEY ); CREATE INDEX LINEITEM_PKEY ON LINEITEM ( L_ORDERKEY , L_LINENUMBER ); CREATE INDEX NATION_N_REGIONKEY_FKEY ON NATION ( N_REGIONKEY ); CREATE INDEX NATION_PKEY ON NATION ( N_NATIONKEY ); CREATE INDEX ORDERS_O_CUSTKEY_FKEY ON ORDERS ( O_CUSTKEY ); CREATE INDEX ORDERS_PKEY ON ORDERS ( O_ORDERKEY ); CREATE INDEX PART_PKEY ON PART ( P_PARTKEY ); CREATE INDEX PARTSUPP_PKEY ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_PARTKEY_FKEY ON PARTSUPP ( PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_SUPPKEY_FKEY ON PARTSUPP ( PS_SUPPKEY ); CREATE INDEX REGION_PKEY ON REGION ( R_REGIONKEY ); CREATE INDEX SUPPLIER_PKEY ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SUPPLIER_S_NATIONKEY_FKEY ON SUPPLIER ( S_NATIONKEY ); Indexes Recommended (before validation) \u00b6 This section contains the list of candidate indexes before the what-if validation. If the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 ; otherwise those candidate indexes only de-duplicate with themselves. -- Recommended indexes (After deduplication with existing indexes above) CREATE INDEX PAW_IDX1496549982 ON NATION ( N_NATIONKEY , N_NAME ); CREATE INDEX PAW_IDX1049412868 ON NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1968327707 ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY , PS_SUPPLYCOST ); CREATE INDEX PAW_IDX1794855777 ON PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX1400713053 ON PARTSUPP ( PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY , PS_PARTKEY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0306025125 ON PART ( P_NAME , P_PARTKEY ); CREATE INDEX PAW_IDX1038398061 ON PART ( P_PARTKEY , P_NAME ); ... Indexes Recommended (after validation) \u00b6 If the What-if analysis validation is checked, those indexes which are verified to gain performance improvement will be listed in this section. Otherwise, this section will be empty. -- After what-if analaysis validation CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); CREATE INDEX PAW_IDX0538538531 ON LINEITEM ( L_ORDERKEY , L_SUPPKEY ); CREATE INDEX PAW_IDX0607681583 ON LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0394351801 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_DISCOUNT , L_EXTENDEDPRICE ); ... The de-duplication alogrithm is adhere to left-most prefix principle. \u21a9","title":"Indexes Recommended"},{"location":"pawindexadvisor/recommended-indexes/#indexes-recommended","text":"After the recommending indexes process is done, there will be two result files generated in the directory of optimized input queries, one is the summary file paw_index.sql and the other is the validation details file paw_index_what_if.txt , outlined as follows: . \u2514\u2500 file1.sql \u2514\u2500 file2.sql \u2514\u2500 paw_index.sql \u2514\u2500 paw_index_what_if.txt","title":"Indexes Recommended"},{"location":"pawindexadvisor/recommended-indexes/#recommendation-summary","text":"The summary file paw_index.sql contains following three section of inforamtion","title":"Recommendation Summary"},{"location":"pawindexadvisor/recommended-indexes/#existing-indexes","text":"This section contains the existing indexes of tables referenced in the input SQL queries. Those tables may not used in the query execution and can be dropped later. -- Existing indexes CREATE INDEX CUSTOMER_C_NATIONKEY_FKEY ON CUSTOMER ( C_NATIONKEY ); CREATE INDEX CUSTOMER_PKEY ON CUSTOMER ( C_CUSTKEY ); CREATE INDEX MYINDEX ON CUSTOMER ( C_NAME , C_PHONE ); CREATE INDEX LINEITEM_L_ORDERKEY_FKEY ON LINEITEM ( L_ORDERKEY ); CREATE INDEX LINEITEM_L_PARTKEY_L_SUPPKEY_FKEY ON LINEITEM ( L_SUPPKEY , L_PARTKEY ); CREATE INDEX LINEITEM_PKEY ON LINEITEM ( L_ORDERKEY , L_LINENUMBER ); CREATE INDEX NATION_N_REGIONKEY_FKEY ON NATION ( N_REGIONKEY ); CREATE INDEX NATION_PKEY ON NATION ( N_NATIONKEY ); CREATE INDEX ORDERS_O_CUSTKEY_FKEY ON ORDERS ( O_CUSTKEY ); CREATE INDEX ORDERS_PKEY ON ORDERS ( O_ORDERKEY ); CREATE INDEX PART_PKEY ON PART ( P_PARTKEY ); CREATE INDEX PARTSUPP_PKEY ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_PARTKEY_FKEY ON PARTSUPP ( PS_PARTKEY ); CREATE INDEX PARTSUPP_PS_SUPPKEY_FKEY ON PARTSUPP ( PS_SUPPKEY ); CREATE INDEX REGION_PKEY ON REGION ( R_REGIONKEY ); CREATE INDEX SUPPLIER_PKEY ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SUPPLIER_S_NATIONKEY_FKEY ON SUPPLIER ( S_NATIONKEY );","title":"Existing Indexes"},{"location":"pawindexadvisor/recommended-indexes/#indexes-recommended-before-validation","text":"This section contains the list of candidate indexes before the what-if validation. If the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 ; otherwise those candidate indexes only de-duplicate with themselves. -- Recommended indexes (After deduplication with existing indexes above) CREATE INDEX PAW_IDX1496549982 ON NATION ( N_NATIONKEY , N_NAME ); CREATE INDEX PAW_IDX1049412868 ON NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1968327707 ON PARTSUPP ( PS_SUPPKEY , PS_PARTKEY , PS_SUPPLYCOST ); CREATE INDEX PAW_IDX1794855777 ON PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX1400713053 ON PARTSUPP ( PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY , PS_PARTKEY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0306025125 ON PART ( P_NAME , P_PARTKEY ); CREATE INDEX PAW_IDX1038398061 ON PART ( P_PARTKEY , P_NAME ); ...","title":"Indexes Recommended (before validation)"},{"location":"pawindexadvisor/recommended-indexes/#indexes-recommended-after-validation","text":"If the What-if analysis validation is checked, those indexes which are verified to gain performance improvement will be listed in this section. Otherwise, this section will be empty. -- After what-if analaysis validation CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); CREATE INDEX PAW_IDX0538538531 ON LINEITEM ( L_ORDERKEY , L_SUPPKEY ); CREATE INDEX PAW_IDX0607681583 ON LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1797601124 ON PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); CREATE INDEX PAW_IDX0949237515 ON PART ( P_PARTKEY , P_TYPE ); CREATE INDEX PAW_IDX0394351801 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_DISCOUNT , L_EXTENDEDPRICE ); ... The de-duplication alogrithm is adhere to left-most prefix principle. \u21a9","title":"Indexes Recommended (after validation)"},{"location":"pawindexadvisor/what-if-validation/","text":"What-if Validation \u00b6 The other result file is the %paw_index_what_if.txt which explains how recommended indexes helps the analyzed queries. This result file is generated only when the What-if analysis validation option is enabled. This file contains a list of query's validation information. For each query, it reveals following information. Query ID \u00b6 The identification of the input query. It is a combinnation of input SQL file name and a \" stmt \" + ordinal of the SQL statement in the input SQL file. So the \" 17.sql-stmt1 \" means the first SQL statement in 17.sql file. - 17.sql-stmt1 -- query id Query Text \u00b6 The orignal query text which is analzed and optimized to improve its performance. SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY ); Performance Improvement \u00b6 The performance improvement(pi) of the query named query id . The performance improvement is calculate according to the cost before and after recommended indexes virtually applied[^2]. - performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] The calculation fomula for pi is pi = (cost_before - cost_after) / cost_after Cost Before \u00b6 The query cost before the recommended indexes are applied. Cost After \u00b6 The query cost after the recommended indexes are applied. Contributing Indexes \u00b6 The indexes contribute to the query execution, including the existing indexes and recommended indexes. - Contributing indice:[PAW_IDX1352615704, PAW_IDX0607681583, PAW_IDX1285498835] -- the indexes used paw_index_what-if.txt \u00b6 /****************************************************************\\ * * * Recommended Index Validation Details * * * * Powered by PawSQL(2022 - ) * * * \\****************************************************************/ -- Recommended indexes CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); ... -- Validation details -- 17.sql1, performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] Contributing indice :[ PAW_IDX1352615704 , PAW_IDX0607681583 , PAW_IDX1285498835 ] SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY ); -- 21.sql1, performance improves by 1173.2289478709183%[cost_before=1333.58,after_cost=104.74] Contributing indice :[ PAW_IDX1621082330 , PAW_IDX1003493942 , PAW_IDX1416165687 , IDX_LINEITEM_ORDERKEY , PAW_IDX0538538531 ] SELECT S_NAME , COUNT ( * ) AS NUMWAIT FROM SUPPLIER , LINEITEM L1 , ORDERS , NATION WHERE S_SUPPKEY = L1 . L_SUPPKEY AND O_ORDERKEY = L1 . L_ORDERKEY AND O_ORDERSTATUS = 'F' AND L1 . L_RECEIPTDATE > L1 . L_COMMITDATE AND EXISTS ( SELECT * FROM LINEITEM L2 WHERE L2 . L_ORDERKEY = L1 . L_ORDERKEY AND L2 . L_SUPPKEY <> L1 . L_SUPPKEY ) AND NOT EXISTS ( SELECT * FROM LINEITEM L3 WHERE L3 . L_ORDERKEY = L1 . L_ORDERKEY AND L3 . L_SUPPKEY <> L1 . L_SUPPKEY AND L3 . L_RECEIPTDATE > L3 . L_COMMITDATE ) AND S_NATIONKEY = N_NATIONKEY AND N_NAME = 'EGYPT' GROUP BY S_NAME ORDER BY NUMWAIT DESC , S_NAME LIMIT 100 ; -- 7.sql1, performance improves by 3877.8084714548804%[cost_before=863.98,after_cost=21.72] Contributing indice :[ PAW_IDX1264424863 , PAW_IDX1409884827 , PAW_IDX1017563074 , CUSTOMER_PKEY , PAW_IDX1640274034 , PAW_IDX1640274034 ] SELECT SUPP_NATION , CUST_NATION , L_YEAR , SUM ( VOLUME ) AS REVENUE FROM ( SELECT N1 . N_NAME AS SUPP_NATION , N2 . N_NAME AS CUST_NATION , EXTRACT ( YEAR FROM L_SHIPDATE ) AS L_YEAR , L_EXTENDEDPRICE * ( 1 - L_DISCOUNT ) AS VOLUME FROM SUPPLIER , LINEITEM , ORDERS , CUSTOMER , NATION N1 , NATION N2 WHERE S_SUPPKEY = L_SUPPKEY AND O_ORDERKEY = L_ORDERKEY AND C_CUSTKEY = O_CUSTKEY AND S_NATIONKEY = N1 . N_NATIONKEY AND C_NATIONKEY = N2 . N_NATIONKEY AND ( ( N1 . N_NAME = 'JAPAN' AND N2 . N_NAME = 'INDIA' ) OR ( N1 . N_NAME = 'INDIA' AND N2 . N_NAME = 'JAPAN' ) ) AND L_SHIPDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31' ) AS SHIPPING GROUP BY SUPP_NATION , CUST_NATION , L_YEAR ORDER BY SUPP_NATION , CUST_NATION , L_YEAR ; ...","title":"What-if Validation"},{"location":"pawindexadvisor/what-if-validation/#what-if-validation","text":"The other result file is the %paw_index_what_if.txt which explains how recommended indexes helps the analyzed queries. This result file is generated only when the What-if analysis validation option is enabled. This file contains a list of query's validation information. For each query, it reveals following information.","title":"What-if Validation"},{"location":"pawindexadvisor/what-if-validation/#query-id","text":"The identification of the input query. It is a combinnation of input SQL file name and a \" stmt \" + ordinal of the SQL statement in the input SQL file. So the \" 17.sql-stmt1 \" means the first SQL statement in 17.sql file. - 17.sql-stmt1 -- query id","title":"Query ID"},{"location":"pawindexadvisor/what-if-validation/#query-text","text":"The orignal query text which is analzed and optimized to improve its performance. SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY );","title":"Query Text"},{"location":"pawindexadvisor/what-if-validation/#performance-improvement","text":"The performance improvement(pi) of the query named query id . The performance improvement is calculate according to the cost before and after recommended indexes virtually applied[^2]. - performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] The calculation fomula for pi is pi = (cost_before - cost_after) / cost_after","title":"Performance Improvement"},{"location":"pawindexadvisor/what-if-validation/#cost-before","text":"The query cost before the recommended indexes are applied.","title":"Cost Before"},{"location":"pawindexadvisor/what-if-validation/#cost-after","text":"The query cost after the recommended indexes are applied.","title":"Cost After"},{"location":"pawindexadvisor/what-if-validation/#contributing-indexes","text":"The indexes contribute to the query execution, including the existing indexes and recommended indexes. - Contributing indice:[PAW_IDX1352615704, PAW_IDX0607681583, PAW_IDX1285498835] -- the indexes used","title":"Contributing Indexes"},{"location":"pawindexadvisor/what-if-validation/#paw_index_what-iftxt","text":"/****************************************************************\\ * * * Recommended Index Validation Details * * * * Powered by PawSQL(2022 - ) * * * \\****************************************************************/ -- Recommended indexes CREATE INDEX PAW_IDX1640274034 ON NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); CREATE INDEX PAW_IDX1120442220 ON LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1003493942 ON SUPPLIER ( S_NATIONKEY , S_SUPPKEY , S_NAME , S_ADDRESS ); CREATE INDEX PAW_IDX1852359742 ON ORDERS ( O_ORDERDATE , O_ORDERKEY , O_CUSTKEY , O_SHIPPRIORITY ); CREATE INDEX PAW_IDX1285498835 ON LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); CREATE INDEX PAW_IDX1728355301 ON LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); CREATE INDEX PAW_IDX1716298676 ON LINEITEM ( L_ORDERKEY , L_QUANTITY ); CREATE INDEX PAW_IDX0711368375 ON PART ( P_TYPE , P_PARTKEY ); ... -- Validation details -- 17.sql1, performance improves by 4318.41%[cost_before=583.23,after_cost=13.2] Contributing indice :[ PAW_IDX1352615704 , PAW_IDX0607681583 , PAW_IDX1285498835 ] SELECT SUM ( L_EXTENDEDPRICE ) / 7 . 0 AS AVG_YEARLY FROM LINEITEM , PART WHERE P_PARTKEY = L_PARTKEY AND P_BRAND = 'BRAND#44' AND P_CONTAINER = 'WRAP PKG' AND L_QUANTITY < ( SELECT 0 . 2 * AVG ( L_QUANTITY ) FROM LINEITEM WHERE L_PARTKEY = P_PARTKEY ); -- 21.sql1, performance improves by 1173.2289478709183%[cost_before=1333.58,after_cost=104.74] Contributing indice :[ PAW_IDX1621082330 , PAW_IDX1003493942 , PAW_IDX1416165687 , IDX_LINEITEM_ORDERKEY , PAW_IDX0538538531 ] SELECT S_NAME , COUNT ( * ) AS NUMWAIT FROM SUPPLIER , LINEITEM L1 , ORDERS , NATION WHERE S_SUPPKEY = L1 . L_SUPPKEY AND O_ORDERKEY = L1 . L_ORDERKEY AND O_ORDERSTATUS = 'F' AND L1 . L_RECEIPTDATE > L1 . L_COMMITDATE AND EXISTS ( SELECT * FROM LINEITEM L2 WHERE L2 . L_ORDERKEY = L1 . L_ORDERKEY AND L2 . L_SUPPKEY <> L1 . L_SUPPKEY ) AND NOT EXISTS ( SELECT * FROM LINEITEM L3 WHERE L3 . L_ORDERKEY = L1 . L_ORDERKEY AND L3 . L_SUPPKEY <> L1 . L_SUPPKEY AND L3 . L_RECEIPTDATE > L3 . L_COMMITDATE ) AND S_NATIONKEY = N_NATIONKEY AND N_NAME = 'EGYPT' GROUP BY S_NAME ORDER BY NUMWAIT DESC , S_NAME LIMIT 100 ; -- 7.sql1, performance improves by 3877.8084714548804%[cost_before=863.98,after_cost=21.72] Contributing indice :[ PAW_IDX1264424863 , PAW_IDX1409884827 , PAW_IDX1017563074 , CUSTOMER_PKEY , PAW_IDX1640274034 , PAW_IDX1640274034 ] SELECT SUPP_NATION , CUST_NATION , L_YEAR , SUM ( VOLUME ) AS REVENUE FROM ( SELECT N1 . N_NAME AS SUPP_NATION , N2 . N_NAME AS CUST_NATION , EXTRACT ( YEAR FROM L_SHIPDATE ) AS L_YEAR , L_EXTENDEDPRICE * ( 1 - L_DISCOUNT ) AS VOLUME FROM SUPPLIER , LINEITEM , ORDERS , CUSTOMER , NATION N1 , NATION N2 WHERE S_SUPPKEY = L_SUPPKEY AND O_ORDERKEY = L_ORDERKEY AND C_CUSTKEY = O_CUSTKEY AND S_NATIONKEY = N1 . N_NATIONKEY AND C_NATIONKEY = N2 . N_NATIONKEY AND ( ( N1 . N_NAME = 'JAPAN' AND N2 . N_NAME = 'INDIA' ) OR ( N1 . N_NAME = 'INDIA' AND N2 . N_NAME = 'JAPAN' ) ) AND L_SHIPDATE BETWEEN DATE '1995-01-01' AND DATE '1996-12-31' ) AS SHIPPING GROUP BY SUPP_NATION , CUST_NATION , L_YEAR ORDER BY SUPP_NATION , CUST_NATION , L_YEAR ; ...","title":"paw_index_what-if.txt"},{"location":"pawreference/","text":"","title":"Material for MkDocs"},{"location":"pawreference/Projection%20Pushdown/","text":"Projection Pushdown \u00b6 Channel of advanced SQL tuning Definition \u00b6 By enabling Projection Pushdown rule, PawSQL eliminates the columns in derived tables, common table expressions and views(after resolving), which are not referenced in outer query blocks, to: - reduce the IO cost - reduce the network cost - enable index recommendation of index-only strategy This justification is similar to rule [RuleStarInSelectList], but PawSQL supplies a rewrite optimization instead of only warning for star in select list scenario. We will use derived table in following paragraph, but all the descriptions also apply to common table expressions and resolved views. Conditions \u00b6 There is no star , except for count(*) , in outer query block, There is no star in the derived table or the common table expression being projection-pushdowned There are some select elements in a derived table or a common table expression which are not referenced in outer query block. Example \u00b6 Derived Table original query select c.c_name, sum(o_totalprice) price FROM customer c, (select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query select c.c_name, sum(dt.o_totalprice) as price from customer as c, ( select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) as dt where c.c_custkey = dt.o_custkey group by c.c_name Common Table Expression original query with dt as ( select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) select c.c_name, sum(o_totalprice) price from customer c, dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query with dt as (select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) select c.c_name, sum(dt.o_totalprice) as price from customer as c, dt where c.c_custkey = dt.o_custkey group by c.c_name Optimization Enablements \u00b6 Projection Pushdown will enable other optimizations in PawSQL and in database engine: Optimizations enabled in PawSQL index recommendation of index-only strategy Optimizations enabled in Database engine index only access in query plan","title":"Projection Pushdown"},{"location":"pawreference/Projection%20Pushdown/#projection-pushdown","text":"Channel of advanced SQL tuning","title":"Projection Pushdown"},{"location":"pawreference/Projection%20Pushdown/#definition","text":"By enabling Projection Pushdown rule, PawSQL eliminates the columns in derived tables, common table expressions and views(after resolving), which are not referenced in outer query blocks, to: - reduce the IO cost - reduce the network cost - enable index recommendation of index-only strategy This justification is similar to rule [RuleStarInSelectList], but PawSQL supplies a rewrite optimization instead of only warning for star in select list scenario. We will use derived table in following paragraph, but all the descriptions also apply to common table expressions and resolved views.","title":"Definition"},{"location":"pawreference/Projection%20Pushdown/#conditions","text":"There is no star , except for count(*) , in outer query block, There is no star in the derived table or the common table expression being projection-pushdowned There are some select elements in a derived table or a common table expression which are not referenced in outer query block.","title":"Conditions"},{"location":"pawreference/Projection%20Pushdown/#example","text":"Derived Table original query select c.c_name, sum(o_totalprice) price FROM customer c, (select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query select c.c_name, sum(dt.o_totalprice) as price from customer as c, ( select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) as dt where c.c_custkey = dt.o_custkey group by c.c_name Common Table Expression original query with dt as ( select c_name, o_custkey, o_totalprice from orders where o_orderpriority=0) select c.c_name, sum(o_totalprice) price from customer c, dt where c.c_custkey = dt.o_custkey group by c.c_name rewritten query with dt as (select orders.o_custkey, orders.o_totalprice from orders where orders.o_orderpriority = 0) select c.c_name, sum(dt.o_totalprice) as price from customer as c, dt where c.c_custkey = dt.o_custkey group by c.c_name","title":"Example"},{"location":"pawreference/Projection%20Pushdown/#optimization-enablements","text":"Projection Pushdown will enable other optimizations in PawSQL and in database engine: Optimizations enabled in PawSQL index recommendation of index-only strategy Optimizations enabled in Database engine index only access in query plan","title":"Optimization Enablements"},{"location":"pawreference/Query%20Folding/","text":"Query Folding \u00b6 Channel of advanced SQL tuning Definition \u00b6 By enabling Query Folding rule, PawSQL merges view references, derived tables and common table expressions to outer query blocks to: - avoid materializing intermediate resultset - enable more join order planning - enable more opportunities for index recommendation We will use view in following paragraph, but all the descriptions also apply to derived tables and common table expressions. Example - original query SELECT * FROM (SELECT c_custkey, c_name FROM customer) AS derived_t1; rewritten query SELECT c_custkey, c_name FROM customer Conditions \u00b6 PawSQL rewrite engine supports two types of query folding strategies, Type 1 - In view itself, there is no distinct or aggregation. - In outer query block, view being folded is not part of an outer join. Type 2 - In outer query block, the view is the only table reference - In outer query block, there is no group by clause and no aggregate functions. Examples \u00b6 Type 1 Query Folding \u00b6 Original query with dt as ( SELECT o_custkey, O_TOTALPRICE FROM orders where o_shippriority=0 ) select c.c_name, sum(O_TOTALPRICE) price FROM customer c, dt WHERE c.c_custkey = dt.o_custkey group by c.c_name Query plan of original query -> Table scan on < temporary > -> Aggregate using temporary table -> Nested loop inner join ( cost = 3806388 . 23 rows = 3400871 ) -> Table scan on dt ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Materialize CTE dt ( cost = 62935 . 41 .. 65430 . 12 rows = 199378 ) -> Table scan on < temporary > ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Temporary table with deduplication ( cost = 40502 . 89 .. 42997 . 60 rows = 199378 ) -> Table scan on orders ( cost = 20565 . 07 rows = 199378 ) -> Index lookup on c using PAW_IDX1614428511 ( C_CUSTKEY = dt . o_custkey ) ( cost = 17 . 06 rows = 17 ) Optimized query select c.c_name, sum(o_totalprice) as price FROM customer c, orders WHERE c.c_custkey = o_custkey and o_shippriority=0 group by c.c_name Query plan of optimized query -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=394660.89 rows=340087) -> Filter: (orders.O_SHIPPRIORITY = 0) (cost=20565.07 rows=19938) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explaination: We can see there is a Materialization step in the query plan of original query, which results from a huge cost. After the rewrite, the materialization step is elimnated and the estimated cost is aboutt 10% of the orignal cost. Type 2 Query Folding \u00b6 Original query with dt as (select c.c_name, sum(O_TOTALPRICE) price FROM customer c, orders WHERE c.c_custkey = orders.o_custkey group by c.c_name) select dt.price from dt where dt.c_name like '139%'; Query plan of original query -> Table scan on dt (cost=2.50..2.50 rows=0) -> Materialize CTE dt (cost=2.50..2.50 rows=0) -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=377837) -> Table scan on orders (cost=20565.07 rows=199378) -> Filter: (c.C_NAME like '139%') (cost=17.06 rows=2) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimized query select sum(orders.O_TOTALPRICE) from customer as c, orders where c.c_custkey = orders.o_custkey group by c.c_name having c.c_name like '139%' Query plan of optimized query -> Filter: (c.C_NAME like '139%') -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=3400871) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explanation: Like type 1, we can see the materialization step is eliminated after the rewrite optimization. Optimization Enablements \u00b6 View folding will reduce blocks by combining conditions or introducing table joins, which will enable other optimizations in PawSQL and optimizations in database engine: Optimizations enabled in PawSQL more efficient index recommendation Optimizations enabled in Database engine avoiding materializing intermediate resultset more join order planning index usage Let's take the type 1 case as an example, PawSQL Index Advisor engine takes the rewritten query as input and recommended a following index. CREATE INDEX PAW_IDX1564931998 ON TPCH . ORDERS ( O_SHIPPRIORITY , O_CUSTKEY , O_TOTALPRICE ); And the final query plan is as follows. -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=95046.40 rows=85935) -> Covering index lookup on orders using PAW_IDX1564931998 (O_SHIPPRIORITY=0) (cost=517.68 rows=5038) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) In the query plan, we can see we eliminates a table scan, and the estimated cost is further reduced to 95046.40 , which is about 2.5% of the original cost 3806388.23 .","title":"Query Folding"},{"location":"pawreference/Query%20Folding/#query-folding","text":"Channel of advanced SQL tuning","title":"Query Folding"},{"location":"pawreference/Query%20Folding/#definition","text":"By enabling Query Folding rule, PawSQL merges view references, derived tables and common table expressions to outer query blocks to: - avoid materializing intermediate resultset - enable more join order planning - enable more opportunities for index recommendation We will use view in following paragraph, but all the descriptions also apply to derived tables and common table expressions. Example - original query SELECT * FROM (SELECT c_custkey, c_name FROM customer) AS derived_t1; rewritten query SELECT c_custkey, c_name FROM customer","title":"Definition"},{"location":"pawreference/Query%20Folding/#conditions","text":"PawSQL rewrite engine supports two types of query folding strategies, Type 1 - In view itself, there is no distinct or aggregation. - In outer query block, view being folded is not part of an outer join. Type 2 - In outer query block, the view is the only table reference - In outer query block, there is no group by clause and no aggregate functions.","title":"Conditions"},{"location":"pawreference/Query%20Folding/#examples","text":"","title":"Examples"},{"location":"pawreference/Query%20Folding/#type-1-query-folding","text":"Original query with dt as ( SELECT o_custkey, O_TOTALPRICE FROM orders where o_shippriority=0 ) select c.c_name, sum(O_TOTALPRICE) price FROM customer c, dt WHERE c.c_custkey = dt.o_custkey group by c.c_name Query plan of original query -> Table scan on < temporary > -> Aggregate using temporary table -> Nested loop inner join ( cost = 3806388 . 23 rows = 3400871 ) -> Table scan on dt ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Materialize CTE dt ( cost = 62935 . 41 .. 65430 . 12 rows = 199378 ) -> Table scan on < temporary > ( cost = 0 . 01 .. 2494 . 72 rows = 199378 ) -> Temporary table with deduplication ( cost = 40502 . 89 .. 42997 . 60 rows = 199378 ) -> Table scan on orders ( cost = 20565 . 07 rows = 199378 ) -> Index lookup on c using PAW_IDX1614428511 ( C_CUSTKEY = dt . o_custkey ) ( cost = 17 . 06 rows = 17 ) Optimized query select c.c_name, sum(o_totalprice) as price FROM customer c, orders WHERE c.c_custkey = o_custkey and o_shippriority=0 group by c.c_name Query plan of optimized query -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=394660.89 rows=340087) -> Filter: (orders.O_SHIPPRIORITY = 0) (cost=20565.07 rows=19938) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explaination: We can see there is a Materialization step in the query plan of original query, which results from a huge cost. After the rewrite, the materialization step is elimnated and the estimated cost is aboutt 10% of the orignal cost.","title":"Type 1 Query Folding"},{"location":"pawreference/Query%20Folding/#type-2-query-folding","text":"Original query with dt as (select c.c_name, sum(O_TOTALPRICE) price FROM customer c, orders WHERE c.c_custkey = orders.o_custkey group by c.c_name) select dt.price from dt where dt.c_name like '139%'; Query plan of original query -> Table scan on dt (cost=2.50..2.50 rows=0) -> Materialize CTE dt (cost=2.50..2.50 rows=0) -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=377837) -> Table scan on orders (cost=20565.07 rows=199378) -> Filter: (c.C_NAME like '139%') (cost=17.06 rows=2) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimized query select sum(orders.O_TOTALPRICE) from customer as c, orders where c.c_custkey = orders.o_custkey group by c.c_name having c.c_name like '139%' Query plan of optimized query -> Filter: (c.C_NAME like '139%') -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=3761523.18 rows=3400871) -> Table scan on orders (cost=20565.07 rows=199378) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) Optimization Explanation: Like type 1, we can see the materialization step is eliminated after the rewrite optimization.","title":"Type 2 Query Folding"},{"location":"pawreference/Query%20Folding/#optimization-enablements","text":"View folding will reduce blocks by combining conditions or introducing table joins, which will enable other optimizations in PawSQL and optimizations in database engine: Optimizations enabled in PawSQL more efficient index recommendation Optimizations enabled in Database engine avoiding materializing intermediate resultset more join order planning index usage Let's take the type 1 case as an example, PawSQL Index Advisor engine takes the rewritten query as input and recommended a following index. CREATE INDEX PAW_IDX1564931998 ON TPCH . ORDERS ( O_SHIPPRIORITY , O_CUSTKEY , O_TOTALPRICE ); And the final query plan is as follows. -> Table scan on <temporary> -> Aggregate using temporary table -> Nested loop inner join (cost=95046.40 rows=85935) -> Covering index lookup on orders using PAW_IDX1564931998 (O_SHIPPRIORITY=0) (cost=517.68 rows=5038) -> Index lookup on c using PAW_IDX1614428511 (C_CUSTKEY=orders.O_CUSTKEY) (cost=17.06 rows=17) In the query plan, we can see we eliminates a table scan, and the estimated cost is further reduced to 95046.40 , which is about 2.5% of the original cost 3806388.23 .","title":"Optimization Enablements"},{"location":"pawreference/audit-rules/","text":"Auditing Rules \u00b6 The auditing rules is from the industry's best practices for query optimization for relational databases. Update with limit \u00b6 Update statements with limit clause can lead to unexpected operation results among multiple runs or slave relay, especailly under a multi-server senario. Postive Case Negative Case update customer set c_custkey = 100 where c_name = 'Ray' limit 1 ; -- Vilation: true update customer set c_custkey = 100 where not c_phone is null ; -- Vilation: false LIMIT with ORDER BY \u00b6 LIMIT queries without ORDER BY clause can result in inconsistent results among multiple executions. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; -- Vilation: false No condidtions for DML statements \u00b6 For Update/merge/delete statements without WHERE condition, or with a condition of where 1=1 , the data malpulation operations will be applied to all rows in the table, which is dangerose and may cause performance issues. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; - Vilation : false INSERT without column names \u00b6 The insert statements should specify column name which can reduce the possibility of misalignment between the inserted values and the columns of the result table. [CASES TO BE ADDED] Avoid starting with wildcard in a LIKE predicate; \u00b6 Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED] Avoid using functional operations on conditional fields; \u00b6 Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED] Avoid implicit conversions on conditional fields; \u00b6 Conditional fields have implicit conversions of numeric values and characters; Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED] Avoid SELECT * \u00b6 The select * syntax is not recommended; Affects subsequent optimization logic and is difficult to maintain. [CASES TO BE ADDED] The level of nested queries exceed the specified threshold \u00b6 SQL that is too complex affects the performance of the plan and is prone to poor performance execution plans. the default value of threshold is 2. [CASES TO BE ADDED] The number of tables in one query block using should not to exceed the threshold \u00b6 SQL that is too complex affects the performance of plan generation and is prone to poor performance execution plans. The default value of threshold is 5. [CASES TO BE ADDED] Use select with \"for update\"\uff1b \u00b6 For update lock tables or lock records. [CASES TO BE ADDED] The number of values of insert statement not exceeding the threshold (default is 500) \u00b6 [CASES TO BE ADDED] Query statements without conditions \u00b6 SQL statements without \"where\" conditions, or with \"where 1=1\", etc, are used, and there are no group aggregation and limit statements. [CASES TO BE ADDED] UNION to UNION ALL rewrite \u00b6 Unions need to be grouped and deduplication, which affects performance. [CASES TO BE ADDED]","title":"Auditing Rules"},{"location":"pawreference/audit-rules/#auditing-rules","text":"The auditing rules is from the industry's best practices for query optimization for relational databases.","title":"Auditing Rules"},{"location":"pawreference/audit-rules/#update-with-limit","text":"Update statements with limit clause can lead to unexpected operation results among multiple runs or slave relay, especailly under a multi-server senario. Postive Case Negative Case update customer set c_custkey = 100 where c_name = 'Ray' limit 1 ; -- Vilation: true update customer set c_custkey = 100 where not c_phone is null ; -- Vilation: false","title":"Update with limit"},{"location":"pawreference/audit-rules/#limit-with-order-by","text":"LIMIT queries without ORDER BY clause can result in inconsistent results among multiple executions. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; -- Vilation: false","title":"LIMIT with ORDER BY"},{"location":"pawreference/audit-rules/#no-condidtions-for-dml-statements","text":"For Update/merge/delete statements without WHERE condition, or with a condition of where 1=1 , the data malpulation operations will be applied to all rows in the table, which is dangerose and may cause performance issues. Postive Case Negative Case select * from customer where c_name = 'Ray' limit 1 ; -- Vilation: true select * from customer where c_name = 'Ray' order by c_custkey limit 1 ; - Vilation : false","title":"No condidtions for DML statements"},{"location":"pawreference/audit-rules/#insert-without-column-names","text":"The insert statements should specify column name which can reduce the possibility of misalignment between the inserted values and the columns of the result table. [CASES TO BE ADDED]","title":"INSERT without column names"},{"location":"pawreference/audit-rules/#avoid-starting-with-wildcard-in-a-like-predicate","text":"Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED]","title":"Avoid starting with wildcard in a LIKE predicate;"},{"location":"pawreference/audit-rules/#avoid-using-functional-operations-on-conditional-fields","text":"Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED]","title":"Avoid using functional operations on conditional fields;"},{"location":"pawreference/audit-rules/#avoid-implicit-conversions-on-conditional-fields","text":"Conditional fields have implicit conversions of numeric values and characters; Unable to quickly locate records using indexes, resulting in full table scans. [CASES TO BE ADDED]","title":"Avoid implicit conversions on conditional fields;"},{"location":"pawreference/audit-rules/#avoid-select","text":"The select * syntax is not recommended; Affects subsequent optimization logic and is difficult to maintain. [CASES TO BE ADDED]","title":"Avoid SELECT *"},{"location":"pawreference/audit-rules/#the-level-of-nested-queries-exceed-the-specified-threshold","text":"SQL that is too complex affects the performance of the plan and is prone to poor performance execution plans. the default value of threshold is 2. [CASES TO BE ADDED]","title":"The level of nested queries exceed the specified threshold"},{"location":"pawreference/audit-rules/#the-number-of-tables-in-one-query-block-using-should-not-to-exceed-the-threshold","text":"SQL that is too complex affects the performance of plan generation and is prone to poor performance execution plans. The default value of threshold is 5. [CASES TO BE ADDED]","title":"The number of tables in one query block using should not to exceed the threshold"},{"location":"pawreference/audit-rules/#use-select-with-for-update","text":"For update lock tables or lock records. [CASES TO BE ADDED]","title":"Use select with \"for update\"\uff1b"},{"location":"pawreference/audit-rules/#the-number-of-values-of-insert-statement-not-exceeding-the-threshold-default-is-500","text":"[CASES TO BE ADDED]","title":"The number of values of insert statement not exceeding the threshold (default is 500)"},{"location":"pawreference/audit-rules/#query-statements-without-conditions","text":"SQL statements without \"where\" conditions, or with \"where 1=1\", etc, are used, and there are no group aggregation and limit statements. [CASES TO BE ADDED]","title":"Query statements without conditions"},{"location":"pawreference/audit-rules/#union-to-union-all-rewrite","text":"Unions need to be grouped and deduplication, which affects performance. [CASES TO BE ADDED]","title":"UNION to UNION ALL rewrite"},{"location":"pawreference/datatype-mismatching/","text":"Implicit Data Type Conversion \u00b6 Channel of advanced SQL tuning Problem \u00b6 Let's say the O_ORDERDATE column in TPCH.ORDERS table is defined as VARCHAR(16) , and there is an index ORDDATE_IDX on ORDERS(O_ORDERDATE) to accelerate the queries against this table if there is a condition on O_ORDERDATE . If we want to count the number of orders of today using following SQL query. select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Use explain to get the query plan: -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) From the query plan, we can see the database optimizer uses a table scan instead of the index lookup as we expected. The query cost is high. Diagnosis \u00b6 Let's replace the function call current_date() with a string value '2022-09-08' , select count ( * ) from ORDERS where O_ORDERDATE = '2022-09-08' ; Use explain to get the query plan: -> Aggregate : count ( 0 ) ( cost = 0 . 50 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) -> Covering index lookup on ORDERS using PAW_IDX1264424863 ( O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) From the query plan , we can see the database optimizer chooses index lookup using index ORDDATE_IDX and the cost is less than 1% of the previous SQL query. Diagnosis: The problem is because of the implicit data type conversion applied on O_ORDERDATE and this conversion disables the index application. When the data types of expressions in a predicate are different, there will be some implicit data type convention operations during query execution (MySQL) 1 . For implicit conventions, some times it happens to the constants in the predicate, sometimes it happens to the column in the predicate. When the convention is applied on the column, the candidate indexes will not be considered during query execution and leading to serious performance problems. Solution \u00b6 The straightful solution is to ensure the expressions used in filtering conditions have the same data type to the column's. For the problematic SQL query, 1. we can either define the O_ORDERDATE as DATE type, or we can use type conversion function cast to make sure the filtering constant with the same data type of column. But both solutions are very prone to mis-usage and time consuming, because the developers need to have the knowledge and check the table definitions from time to time. That is where the query tuning tool, such as PawSQL, fills in. PawSQL auto-rewrites \u00b6 There is a rewrite optimization rule [DiffDataTypeInPredicateRewrite] in PawSQL to automatically detect the data type mis-matching in SQL queries and provide automatic rewrite optmization. Conditions \u00b6 The predicate is between a table column and simple value expressions 2 The table column has a different data type from the simple value expressions. Support following three type of predicates column operator expr column between expr1 and expr2 column in ( expr1 , expr2 , ) Example Cases \u00b6 Case 1 : column operator expr - Input Query select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Query Plan for input query -> Aggregate : count ( orders . O_CUSTKEY ) ( cost = 4614 . 83 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) Optimized Query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE = cast ( current_date () as CHAR ( 16 )); Query Plan for the optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 20 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on ORDERS using o_orderdate_idx ( O_ORDERDATE = cast ( curdate () as char ( 16 ) charset utf8mb4 )) ( cost = 1 . 10 rows = 1 ) Optimization Explanation: O_ORDERDATE is type of CHAR(16) in table definition, and current_date() is type of DATE , so index on O_ORDERDATE is not applicable, and the estimated cost is 4614.83 . PawSQL rewrites current_date() to cast(current_date() as CHAR(16)) , so the index on O_ORDERDATE is chosen by the database optimizer and the cost is reduce to 1.20 , which is less than 0.1%. Case 2 : column between expr1 and expr2 - Input query select count ( * ) from ORDERS where O_ORDERDATE between current_date () and DATE_ADD ( CURRENT_DATE (), INTERVAL 1 DAY ); - Query plan for input query -> Aggregate : count ( orders . O_ORDERKEY ) ( cost = 5057 . 45 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( curdate ()) and < cache > (( curdate () + interval 1 day ))) ( cost = 2842 . 36 rows = 22151 ) -> Table scan on ORDERS ( cost = 2842 . 36 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE between cast ( current_date () as CHAR ( 16 )) and cast ( DATE_ADD ( CURRENT_DATE (), interval '1' DAY ) as CHAR ( 16 )) - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 31 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )) and < cache > ( cast (( curdate () + interval '1' day ) as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 21 rows = 1 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( '2022-09-14' <= O_ORDERDATE <= '2022-09-15' ) ( cost = 1 . 21 rows = 1 ) __Optimization Explanation:__ `DATE_ADD(CURRENT_DATE(), INTERVAL 1 DAY)` is a nested function and it's final result is type of `DATE`, which is not compatible with `CHAR(16)`. So it's rewritten to cast(DATE_ADD(CURRENT_DATE(), interval '1' DAY) as CHAR(16)). And the cost is reduced to ***1.31*** from ***5057.45***. Case 3 : column in ( expr1 , expr2 , ...) - Input query select count ( * ) from ORDERS where O_ORDERDATE in ( current_date (), '2022-10-01' ); - Query Plan for input query -> Aggregate : count ( 0 ) ( cost = 8602 . 39 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( curdate ()), '2022-10-01' )) ( cost = 4614 . 83 rows = 39876 ) -> Index scan on ORDERS using o_orderdate_idx ( cost = 4614 . 83 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE in ( cast ( current_date () as CHAR ( 16 )), '2022-10-01' ); - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 62 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )), '2022-10-01' )) ( cost = 1 . 42 rows = 2 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( O_ORDERDATE = '2022-09-14' ) OR ( O_ORDERDATE = '2022-10-01' ) ( cost = 1 . 42 rows = 2 ) __Optimization Explanation:__ `current_date()` is written to `cast(current_date() as CHAR(16))`, and `'2022-10-01'` is type of character string, which is compatible with the type of column `O_ORDERDATE`. It is no need to rewrite it. And the cost is reduced to ***1.62*** from ***8602.39***. For PostgreSQL, instead of applying data type conversion implicitly, there will be an error thrown by the database to notify users there should be some explicit type conventions to add. \u21a9 Simple value expressions refer to constants or expressions/functions which are evaluated to a constant, such as current_date() , 1 + 2 , concate('first name', 'last name') . \u21a9","title":"Datatype Mismatching Rewrite"},{"location":"pawreference/datatype-mismatching/#implicit-data-type-conversion","text":"Channel of advanced SQL tuning","title":"Implicit Data Type Conversion"},{"location":"pawreference/datatype-mismatching/#problem","text":"Let's say the O_ORDERDATE column in TPCH.ORDERS table is defined as VARCHAR(16) , and there is an index ORDDATE_IDX on ORDERS(O_ORDERDATE) to accelerate the queries against this table if there is a condition on O_ORDERDATE . If we want to count the number of orders of today using following SQL query. select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Use explain to get the query plan: -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) From the query plan, we can see the database optimizer uses a table scan instead of the index lookup as we expected. The query cost is high.","title":"Problem"},{"location":"pawreference/datatype-mismatching/#diagnosis","text":"Let's replace the function call current_date() with a string value '2022-09-08' , select count ( * ) from ORDERS where O_ORDERDATE = '2022-09-08' ; Use explain to get the query plan: -> Aggregate : count ( 0 ) ( cost = 0 . 50 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) -> Covering index lookup on ORDERS using PAW_IDX1264424863 ( O_ORDERDATE = '2022-09-08' ) ( cost = 0 . 40 rows = 1 ) From the query plan , we can see the database optimizer chooses index lookup using index ORDDATE_IDX and the cost is less than 1% of the previous SQL query. Diagnosis: The problem is because of the implicit data type conversion applied on O_ORDERDATE and this conversion disables the index application. When the data types of expressions in a predicate are different, there will be some implicit data type convention operations during query execution (MySQL) 1 . For implicit conventions, some times it happens to the constants in the predicate, sometimes it happens to the column in the predicate. When the convention is applied on the column, the candidate indexes will not be considered during query execution and leading to serious performance problems.","title":"Diagnosis"},{"location":"pawreference/datatype-mismatching/#solution","text":"The straightful solution is to ensure the expressions used in filtering conditions have the same data type to the column's. For the problematic SQL query, 1. we can either define the O_ORDERDATE as DATE type, or we can use type conversion function cast to make sure the filtering constant with the same data type of column. But both solutions are very prone to mis-usage and time consuming, because the developers need to have the knowledge and check the table definitions from time to time. That is where the query tuning tool, such as PawSQL, fills in.","title":"Solution"},{"location":"pawreference/datatype-mismatching/#pawsql-auto-rewrites","text":"There is a rewrite optimization rule [DiffDataTypeInPredicateRewrite] in PawSQL to automatically detect the data type mis-matching in SQL queries and provide automatic rewrite optmization.","title":"PawSQL auto-rewrites"},{"location":"pawreference/datatype-mismatching/#conditions","text":"The predicate is between a table column and simple value expressions 2 The table column has a different data type from the simple value expressions. Support following three type of predicates column operator expr column between expr1 and expr2 column in ( expr1 , expr2 , )","title":"Conditions"},{"location":"pawreference/datatype-mismatching/#example-cases","text":"Case 1 : column operator expr - Input Query select count ( * ) from ORDERS where O_ORDERDATE = current_date (); Query Plan for input query -> Aggregate : count ( orders . O_CUSTKEY ) ( cost = 4614 . 83 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( curdate ())) ( cost = 2621 . 05 rows = 19938 ) -> Table scan on ORDERS ( cost = 2621 . 05 rows = 199378 ) Optimized Query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE = cast ( current_date () as CHAR ( 16 )); Query Plan for the optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 20 rows = 1 ) -> Filter : ( orders . O_ORDERDATE = < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on ORDERS using o_orderdate_idx ( O_ORDERDATE = cast ( curdate () as char ( 16 ) charset utf8mb4 )) ( cost = 1 . 10 rows = 1 ) Optimization Explanation: O_ORDERDATE is type of CHAR(16) in table definition, and current_date() is type of DATE , so index on O_ORDERDATE is not applicable, and the estimated cost is 4614.83 . PawSQL rewrites current_date() to cast(current_date() as CHAR(16)) , so the index on O_ORDERDATE is chosen by the database optimizer and the cost is reduce to 1.20 , which is less than 0.1%. Case 2 : column between expr1 and expr2 - Input query select count ( * ) from ORDERS where O_ORDERDATE between current_date () and DATE_ADD ( CURRENT_DATE (), INTERVAL 1 DAY ); - Query plan for input query -> Aggregate : count ( orders . O_ORDERKEY ) ( cost = 5057 . 45 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( curdate ()) and < cache > (( curdate () + interval 1 day ))) ( cost = 2842 . 36 rows = 22151 ) -> Table scan on ORDERS ( cost = 2842 . 36 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE between cast ( current_date () as CHAR ( 16 )) and cast ( DATE_ADD ( CURRENT_DATE (), interval '1' DAY ) as CHAR ( 16 )) - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 31 rows = 1 ) -> Filter : ( orders . O_ORDERDATE between < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )) and < cache > ( cast (( curdate () + interval '1' day ) as char ( 16 ) charset utf8mb4 ))) ( cost = 1 . 21 rows = 1 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( '2022-09-14' <= O_ORDERDATE <= '2022-09-15' ) ( cost = 1 . 21 rows = 1 ) __Optimization Explanation:__ `DATE_ADD(CURRENT_DATE(), INTERVAL 1 DAY)` is a nested function and it's final result is type of `DATE`, which is not compatible with `CHAR(16)`. So it's rewritten to cast(DATE_ADD(CURRENT_DATE(), interval '1' DAY) as CHAR(16)). And the cost is reduced to ***1.31*** from ***5057.45***. Case 3 : column in ( expr1 , expr2 , ...) - Input query select count ( * ) from ORDERS where O_ORDERDATE in ( current_date (), '2022-10-01' ); - Query Plan for input query -> Aggregate : count ( 0 ) ( cost = 8602 . 39 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( curdate ()), '2022-10-01' )) ( cost = 4614 . 83 rows = 39876 ) -> Index scan on ORDERS using o_orderdate_idx ( cost = 4614 . 83 rows = 199378 ) - Optimized query select count ( * ) from TPCH . ORDERS where ORDERS . O_ORDERDATE in ( cast ( current_date () as CHAR ( 16 )), '2022-10-01' ); - Query plan for optimized query -> Aggregate : count ( 0 ) ( cost = 1 . 62 rows = 1 ) -> Filter : ( orders . O_ORDERDATE in ( < cache > ( cast ( curdate () as char ( 16 ) charset utf8mb4 )), '2022-10-01' )) ( cost = 1 . 42 rows = 2 ) -> Covering index range scan on ORDERS using o_orderdate_idx over ( O_ORDERDATE = '2022-09-14' ) OR ( O_ORDERDATE = '2022-10-01' ) ( cost = 1 . 42 rows = 2 ) __Optimization Explanation:__ `current_date()` is written to `cast(current_date() as CHAR(16))`, and `'2022-10-01'` is type of character string, which is compatible with the type of column `O_ORDERDATE`. It is no need to rewrite it. And the cost is reduced to ***1.62*** from ***8602.39***. For PostgreSQL, instead of applying data type conversion implicitly, there will be an error thrown by the database to notify users there should be some explicit type conventions to add. \u21a9 Simple value expressions refer to constants or expressions/functions which are evaluated to a constant, such as current_date() , 1 + 2 , concate('first name', 'last name') . \u21a9","title":"Example Cases"},{"location":"pawreference/rewrite-rules/","text":"Rewrite Rules \u00b6 There are many ways to write different SQLs to get the same result. Some of them are in-efficient, and some of them are very efficient. PawSQL rewrite engine helps you to detect the in-efficient SQL statements and rewrite them to semantically equivalent, but more efficient SQLs. Equal to NULL rewrite \u00b6 From the article [Four Traps of SQL Processing with NULL Values], we know that expr = null or case expr when nulll can\u2019t determine the expression expr to be null , and is null should be used to determine that the expression is null. Case 1. expr = null \u00b6 with t as ( select null as c union select 1 as c ) select count ( * ) from t where t . c = null ; Expected result Actual result Rewritten SQL by PawSQL 1 0 with t as ( select null as c union select 1 as c ) select count ( * ) from t where t . c is null ; Case 2. case expr when null \u00b6 with t as ( select null as c union select 1 as c ) select case t . c when 1 then 'a' when null then 'b' else 'c' end from t ; Expected result Actual result Rewritten SQL 'a' 'b' 'a' 'c' ``` sql with t as ( select null as c union select 1 as c ) select case when t.c = 1 then 'a' when t.c is null then 'b' else 'c' end from t; ``` Nullable NOT IN rewrite \u00b6 A not in subquery with nullable select elements will always be false. For detailed information, please refer to [Four Traps of SQL Processing with NULL Values]. Conditions There is a not in subquery predicate. At least one of the select elements in subquery is nullable. with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 not in ( select c from t ); Expected result Actual result Rewritten SQL 2 with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 not in ( select c from t where t . c is not null ); Nullable ALL rewrite \u00b6 A condition of an ALL -qualified subquery will always be evaluated to false. For detailed information, please refer to [Four Traps of SQL Processing with NULL Values]. Conditions There is a ALL -qualified subquery predicate. At least one of the select elements in subquery is nullable. Example Query with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 > all ( select c from t ); Expected result Actual result Rewritten SQL 2 with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 > ( select max ( c ) from t ); MAX/MIN SSQ rewrite \u00b6 MAX/MIN SSQ can be rewritten to take advantage of B+ tree ordering to avoid sorting and accessing unnecessary data. Conditions There is a MAX or MIN scalar subquery predicate. Example Query select * from customer where c_custkey = ( select max ( o_custkey ) from orders ) Rewritten Query by PawSQL MySQL doesn't support nulls last or nulls first syntax. So for MySQL, if the column in the aggregate function is nullable, PawSQL Advisor will add an is not null predicate to WHERE clause. PostgreSQL MySQL select * from customer where c_custkey = ( select o_custkey from orders order by o_custkey desc nulls last limit 1 ); select * from customer where c_custkey = ( select o_custkey from orders where o_custkey is not null order by o_custkey desc limit 1 ); Explain Plan Query Plan(Before Optimized) Query Plan(After Optimized) Index Scan using customer_pkey on customer ( cost = 309 . 31 .. 317 . 32 rows = 1 width = 181 ) Index Cond : ( c_custkey = $ 0 ) InitPlan 1 ( returns $ 0 ) -> Aggregate ( cost = 309 . 01 .. 309 . 02 rows = 1 width = 4 ) -> Seq Scan on orders ( cost = 0 . 00 .. 284 . 01 rows = 10001 width = 4 ) Index Scan using customer_pkey on customer ( cost = 0 . 60 .. 8 . 62 rows = 1 width = 181 ) Index Cond : ( c_custkey = $ 1 ) InitPlan 2 ( returns $ 1 ) -> Result ( cost = 0 . 31 .. 0 . 32 rows = 1 width = 4 ) InitPlan 1 ( returns $ 0 ) -> Limit ( cost = 0 . 29 .. 0 . 31 rows = 1 width = 4 ) -> Index Only Scan Backward using paw_idx1196677611 on orders ( cost = 0 . 29 .. 235 . 30 rows = 10001 width = 4 ) Index Cond : ( o_custkey IS NOT NULL ) COUNT SSQ rewrite \u00b6 COUNT SSQ queries ( count(*) > 0 or count(col) > 0 ) can be rewritten as EXISTS subquery. EXISTS subquery will return immidiately when a qualified row is found, which is much faster than a COUNT aggregation operation which examines all rows. Conditions There is a COUNT SSQ(scalar subquery) >0 predicate in query block. Example Query select * from TPCH . customer where ( select count ( orders . o_custkey ) from TPCH . orders where orders . o_custkey = c_custkey ) > 0 ; Rewritten Query by PawSQL select * from TPCH . customer where exists ( select orders . o_custkey from TPCH . orders where ( orders . o_custkey = c_custkey and orders . o_custkey is not null )); Explain Plan Query Plan(Before Optimized) Query Plan(After Optimized) -> Filter : (( select # 2 ) > 0 ) ( cost = 90373 . 50 rows = 795135 ) ( actual time = 2 . 131 .. 6628 . 035 rows = 528640 loops = 1 ) -> Table scan on customer ( cost = 90373 . 50 rows = 795135 ) ( actual time = 1 . 232 .. 1510 . 298 rows = 806513 loops = 1 ) -> Select # 2 ( subquery in condition ; dependent ) -> Aggregate : count ( orders . O_CUSTKEY ) ( cost = 2 . 53 rows = 1 ) ( actual time = 0 . 006 .. 0 . 006 rows = 1 loops = 806513 ) -> Covering index lookup on orders using PAW_IDX1403958132 ( O_CUSTKEY = customer . C_CUSTKEY ) ( cost = 1 . 50 rows = 10 ) ( actual time = 0 . 002 .. 0 . 005 rows = 7 loops = 806513 ) -> Nested loop inner join ( cost = 8089316782 . 50 rows = 80891468955 ) ( actual time = 103 . 807 .. 1415 . 534 rows = 528640 loops = 1 ) -> Table scan on customer ( cost = 90373 . 50 rows = 795135 ) ( actual time = 0 . 028 .. 860 . 400 rows = 806513 loops = 1 ) -> Single - row index lookup on < subquery2 > using < auto_distinct_key > ( o_custkey = customer . C_CUSTKEY ) ( actual time = 0 . 000 .. 0 . 000 rows = 1 loops = 806513 ) -> Materialize with deduplication ( cost = 20578 . 85 .. 20578 . 85 rows = 101733 ) ( actual time = 377 . 881 .. 431 . 729 rows = 10001 loops = 1 ) -> Covering index scan on orders using PAW_IDX1264424863 ( cost = 10405 . 55 rows = 101733 ) ( actual time = 0 . 266 .. 72 . 884 rows = 102617 loops = 1 ) OR conditioned UPDATE/DELETE rewrite \u00b6 Conditions including OR combined predicates can't not take advantage of indexes[^1], PawSQL can help you to break the OR combined predicates down into multiple independent update/delete statements. So that each of the statements can take advantage of indexes. [CASES TO BE ADDED] OR conditioned SELECT rewrite \u00b6 Conditions including OR combined predicates can't not take advantage of indexes[^1], PawSQL can help you to rewrite your SQL queries to UNION or UNION ALL queries so every query block can take advantage of indexes. [CASES TO BE ADDED] Predicate Pushdown \u00b6 Push having clauses into the where clause, so that the database can do filtering first to reduce the dataset size to improve performance. [CASES TO BE ADDED] ORDER BY without LIMIT \u00b6 Delete/update statements shouldn't have \"order by\" without \"limit\". Sorting without Limit doesn't make sense, but it makes performance worse. [CASES TO BE ADDED]","title":"Rewrite Optimization"},{"location":"pawreference/rewrite-rules/#rewrite-rules","text":"There are many ways to write different SQLs to get the same result. Some of them are in-efficient, and some of them are very efficient. PawSQL rewrite engine helps you to detect the in-efficient SQL statements and rewrite them to semantically equivalent, but more efficient SQLs.","title":"Rewrite Rules"},{"location":"pawreference/rewrite-rules/#equal-to-null-rewrite","text":"From the article [Four Traps of SQL Processing with NULL Values], we know that expr = null or case expr when nulll can\u2019t determine the expression expr to be null , and is null should be used to determine that the expression is null.","title":"Equal to NULL rewrite"},{"location":"pawreference/rewrite-rules/#case-1-expr-null","text":"with t as ( select null as c union select 1 as c ) select count ( * ) from t where t . c = null ; Expected result Actual result Rewritten SQL by PawSQL 1 0 with t as ( select null as c union select 1 as c ) select count ( * ) from t where t . c is null ;","title":"Case 1. expr = null"},{"location":"pawreference/rewrite-rules/#case-2-case-expr-when-null","text":"with t as ( select null as c union select 1 as c ) select case t . c when 1 then 'a' when null then 'b' else 'c' end from t ; Expected result Actual result Rewritten SQL 'a' 'b' 'a' 'c' ``` sql with t as ( select null as c union select 1 as c ) select case when t.c = 1 then 'a' when t.c is null then 'b' else 'c' end from t; ```","title":"Case 2. case expr when null"},{"location":"pawreference/rewrite-rules/#nullable-not-in-rewrite","text":"A not in subquery with nullable select elements will always be false. For detailed information, please refer to [Four Traps of SQL Processing with NULL Values]. Conditions There is a not in subquery predicate. At least one of the select elements in subquery is nullable. with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 not in ( select c from t ); Expected result Actual result Rewritten SQL 2 with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 not in ( select c from t where t . c is not null );","title":"Nullable NOT IN rewrite"},{"location":"pawreference/rewrite-rules/#nullable-all-rewrite","text":"A condition of an ALL -qualified subquery will always be evaluated to false. For detailed information, please refer to [Four Traps of SQL Processing with NULL Values]. Conditions There is a ALL -qualified subquery predicate. At least one of the select elements in subquery is nullable. Example Query with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 > all ( select c from t ); Expected result Actual result Rewritten SQL 2 with t as ( select null as c union select 1 as c ), t1 as ( select 2 as c1 ) select * from t1 where t1 . c1 > ( select max ( c ) from t );","title":"Nullable ALL rewrite"},{"location":"pawreference/rewrite-rules/#maxmin-ssq-rewrite","text":"MAX/MIN SSQ can be rewritten to take advantage of B+ tree ordering to avoid sorting and accessing unnecessary data. Conditions There is a MAX or MIN scalar subquery predicate. Example Query select * from customer where c_custkey = ( select max ( o_custkey ) from orders ) Rewritten Query by PawSQL MySQL doesn't support nulls last or nulls first syntax. So for MySQL, if the column in the aggregate function is nullable, PawSQL Advisor will add an is not null predicate to WHERE clause. PostgreSQL MySQL select * from customer where c_custkey = ( select o_custkey from orders order by o_custkey desc nulls last limit 1 ); select * from customer where c_custkey = ( select o_custkey from orders where o_custkey is not null order by o_custkey desc limit 1 ); Explain Plan Query Plan(Before Optimized) Query Plan(After Optimized) Index Scan using customer_pkey on customer ( cost = 309 . 31 .. 317 . 32 rows = 1 width = 181 ) Index Cond : ( c_custkey = $ 0 ) InitPlan 1 ( returns $ 0 ) -> Aggregate ( cost = 309 . 01 .. 309 . 02 rows = 1 width = 4 ) -> Seq Scan on orders ( cost = 0 . 00 .. 284 . 01 rows = 10001 width = 4 ) Index Scan using customer_pkey on customer ( cost = 0 . 60 .. 8 . 62 rows = 1 width = 181 ) Index Cond : ( c_custkey = $ 1 ) InitPlan 2 ( returns $ 1 ) -> Result ( cost = 0 . 31 .. 0 . 32 rows = 1 width = 4 ) InitPlan 1 ( returns $ 0 ) -> Limit ( cost = 0 . 29 .. 0 . 31 rows = 1 width = 4 ) -> Index Only Scan Backward using paw_idx1196677611 on orders ( cost = 0 . 29 .. 235 . 30 rows = 10001 width = 4 ) Index Cond : ( o_custkey IS NOT NULL )","title":"MAX/MIN SSQ rewrite"},{"location":"pawreference/rewrite-rules/#count-ssq-rewrite","text":"COUNT SSQ queries ( count(*) > 0 or count(col) > 0 ) can be rewritten as EXISTS subquery. EXISTS subquery will return immidiately when a qualified row is found, which is much faster than a COUNT aggregation operation which examines all rows. Conditions There is a COUNT SSQ(scalar subquery) >0 predicate in query block. Example Query select * from TPCH . customer where ( select count ( orders . o_custkey ) from TPCH . orders where orders . o_custkey = c_custkey ) > 0 ; Rewritten Query by PawSQL select * from TPCH . customer where exists ( select orders . o_custkey from TPCH . orders where ( orders . o_custkey = c_custkey and orders . o_custkey is not null )); Explain Plan Query Plan(Before Optimized) Query Plan(After Optimized) -> Filter : (( select # 2 ) > 0 ) ( cost = 90373 . 50 rows = 795135 ) ( actual time = 2 . 131 .. 6628 . 035 rows = 528640 loops = 1 ) -> Table scan on customer ( cost = 90373 . 50 rows = 795135 ) ( actual time = 1 . 232 .. 1510 . 298 rows = 806513 loops = 1 ) -> Select # 2 ( subquery in condition ; dependent ) -> Aggregate : count ( orders . O_CUSTKEY ) ( cost = 2 . 53 rows = 1 ) ( actual time = 0 . 006 .. 0 . 006 rows = 1 loops = 806513 ) -> Covering index lookup on orders using PAW_IDX1403958132 ( O_CUSTKEY = customer . C_CUSTKEY ) ( cost = 1 . 50 rows = 10 ) ( actual time = 0 . 002 .. 0 . 005 rows = 7 loops = 806513 ) -> Nested loop inner join ( cost = 8089316782 . 50 rows = 80891468955 ) ( actual time = 103 . 807 .. 1415 . 534 rows = 528640 loops = 1 ) -> Table scan on customer ( cost = 90373 . 50 rows = 795135 ) ( actual time = 0 . 028 .. 860 . 400 rows = 806513 loops = 1 ) -> Single - row index lookup on < subquery2 > using < auto_distinct_key > ( o_custkey = customer . C_CUSTKEY ) ( actual time = 0 . 000 .. 0 . 000 rows = 1 loops = 806513 ) -> Materialize with deduplication ( cost = 20578 . 85 .. 20578 . 85 rows = 101733 ) ( actual time = 377 . 881 .. 431 . 729 rows = 10001 loops = 1 ) -> Covering index scan on orders using PAW_IDX1264424863 ( cost = 10405 . 55 rows = 101733 ) ( actual time = 0 . 266 .. 72 . 884 rows = 102617 loops = 1 )","title":"COUNT SSQ rewrite"},{"location":"pawreference/rewrite-rules/#or-conditioned-updatedelete-rewrite","text":"Conditions including OR combined predicates can't not take advantage of indexes[^1], PawSQL can help you to break the OR combined predicates down into multiple independent update/delete statements. So that each of the statements can take advantage of indexes. [CASES TO BE ADDED]","title":"OR conditioned UPDATE/DELETE rewrite"},{"location":"pawreference/rewrite-rules/#or-conditioned-select-rewrite","text":"Conditions including OR combined predicates can't not take advantage of indexes[^1], PawSQL can help you to rewrite your SQL queries to UNION or UNION ALL queries so every query block can take advantage of indexes. [CASES TO BE ADDED]","title":"OR conditioned SELECT rewrite"},{"location":"pawreference/rewrite-rules/#predicate-pushdown","text":"Push having clauses into the where clause, so that the database can do filtering first to reduce the dataset size to improve performance. [CASES TO BE ADDED]","title":"Predicate Pushdown"},{"location":"pawreference/rewrite-rules/#order-by-without-limit","text":"Delete/update statements shouldn't have \"order by\" without \"limit\". Sorting without Limit doesn't make sense, but it makes performance worse. [CASES TO BE ADDED]","title":"ORDER BY without LIMIT"},{"location":"pawreference/sql-syntax/","text":"SQL syntax and indexes \u00b6 Indexes serve the following three purposes from the performance perspective: Quickly locate data recording (equivalent conditions, range conditions); Avoid sorting (order by/group by/distinct/union/sort merge join); Avoid probing data from the heap table, by accessing only the index file. We use TPCH schema to demonstrate the capability of Paw Index Advisor. Sample SQLs with primary syntax are listed below, with one or two indice recommended for each SQL. Single Table Queries \u00b6 1. Equal conditions \u00b6 -- equal select * from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE ); select * from lineitem where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' , '1' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode <=> '0' ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipdate = ( select max ( l_shipdate ) from lineitem ); CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); 2.Range Conditions \u00b6 -- range select * from lineitem where l_shipdate >= date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0156881833 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate between date '2010-12-01' and date '2020-12-01' ; CREATE INDEX SQLLAB_IDX1241878058 ON LINEITEM ( L_SHIPDATE ) \uff1b select * from customer where c_phone like \"139%\" ; CREATE INDEX SQLLAB_IDX0326568991 ON CUSTOMER ( C_PHONE ); 3.Grouping and Ordering \u00b6 -- grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate ; CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE \uff0c L_QUANTITY ); -- index only -- ordering select * from lineitem order by l_shipdate limit 10 ; CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE ); 4.Combinition of syntax \u00b6 -- equal + range select * from lineitem where l_shipdate = date '1998-12-01' and l_quantity > 100 ; CREATE INDEX SQLLAB_IDX2048143506 ON LINEITEM ( L_SHIPDATE , L_QUANTITY ); -- ordering+grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate order by l_shipdate ; CREATE INDEX SQLLAB_IDX1360881332 ON LINEITEM ( L_SHIPDATE ); -- where+group select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem where l_receiptdate = '2020-01-01' group by l_shipdate ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_RECEIPTDATE , L_SHIPDATE , l_quantity ); Table Joins \u00b6 SELECT * FROM ORDERS , LINEITEM WHERE O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX2127618499 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX0339323878 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1531629550 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1365836084 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1336974557 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS RIGHT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1002609246 ON ORDERS ( O_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY WHERE l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0711368375 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE ); Subqueries \u00b6 -- subquery1 select * from supplier ,( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) revenue where s_suppkey = revenue . l_suppkey ; CREATE INDEX SQLLAB_IDX0151075817 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1968327707 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE ); -- subquery2 select * from supplier where s_suppkey = ( select l_suppkey from lineitem order by l_suppkey desc limit 1 ); CREATE INDEX SQLLAB_IDX0664775210 ON SUPPLIER ( S_SUPPKEY ); -- subquery3 with revenue as ( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) select * from supplier , revenue where s_suppkey = l_suppkey ; CREATE INDEX SQLLAB_IDX0343576594 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1518532301 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE ); Query Rewrite \u00b6 1.Transitive Closure \u00b6 -- example 1 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234' ; CREATE INDEX SQLLAB_IDX0837835805 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1989932894 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 2 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey > 'ORD1234' ; CREATE INDEX SQLLAB_IDX1000938250 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1358517686 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 3 select c_custkey , c_name , sum ( l_extendedprice * ( 1 - l_discount )) as revenue from customer , orders , lineitem where c_custkey = o_orderkey and l_orderkey = o_orderkey and l_orderkey = 'ORD1234' group by c_custkey , c_name ; CREATE INDEX SQLLAB_IDX1161414921 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1584481406 ON CUSTOMER ( C_CUSTKEY , C_NAME ); CREATE INDEX SQLLAB_IDX0637857516 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); 2.Ordinal \u00b6 -- orderby ordinal select * from lineitem order by l_shipdate limit 10 CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE ); sql -- groupby ordinal select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by 1 CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE , L_QUANTITY ); Update/Delete/Insert/Merge \u00b6 delete from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); update lineitem set l_shipmode = '' where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); insert into lineitem select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); replace into lineitem select * where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE );","title":"SQL Syntax&Indexes"},{"location":"pawreference/sql-syntax/#sql-syntax-and-indexes","text":"Indexes serve the following three purposes from the performance perspective: Quickly locate data recording (equivalent conditions, range conditions); Avoid sorting (order by/group by/distinct/union/sort merge join); Avoid probing data from the heap table, by accessing only the index file. We use TPCH schema to demonstrate the capability of Paw Index Advisor. Sample SQLs with primary syntax are listed below, with one or two indice recommended for each SQL.","title":"SQL syntax and indexes"},{"location":"pawreference/sql-syntax/#single-table-queries","text":"","title":"Single Table Queries"},{"location":"pawreference/sql-syntax/#1-equal-conditions","text":"-- equal select * from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE ); select * from lineitem where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode in ( '0' , '1' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipmode <=> '0' ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); select * from lineitem where l_shipdate = ( select max ( l_shipdate ) from lineitem ); CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE );","title":"1. Equal conditions"},{"location":"pawreference/sql-syntax/#2range-conditions","text":"-- range select * from lineitem where l_shipdate >= date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0156881833 ON LINEITEM ( L_SHIPDATE ); select * from lineitem where l_shipdate between date '2010-12-01' and date '2020-12-01' ; CREATE INDEX SQLLAB_IDX1241878058 ON LINEITEM ( L_SHIPDATE ) \uff1b select * from customer where c_phone like \"139%\" ; CREATE INDEX SQLLAB_IDX0326568991 ON CUSTOMER ( C_PHONE );","title":"2.Range Conditions"},{"location":"pawreference/sql-syntax/#3grouping-and-ordering","text":"-- grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate ; CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE \uff0c L_QUANTITY ); -- index only -- ordering select * from lineitem order by l_shipdate limit 10 ; CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE );","title":"3.Grouping and Ordering"},{"location":"pawreference/sql-syntax/#4combinition-of-syntax","text":"-- equal + range select * from lineitem where l_shipdate = date '1998-12-01' and l_quantity > 100 ; CREATE INDEX SQLLAB_IDX2048143506 ON LINEITEM ( L_SHIPDATE , L_QUANTITY ); -- ordering+grouping select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by l_shipdate order by l_shipdate ; CREATE INDEX SQLLAB_IDX1360881332 ON LINEITEM ( L_SHIPDATE ); -- where+group select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem where l_receiptdate = '2020-01-01' group by l_shipdate ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_RECEIPTDATE , L_SHIPDATE , l_quantity );","title":"4.Combinition of syntax"},{"location":"pawreference/sql-syntax/#table-joins","text":"SELECT * FROM ORDERS , LINEITEM WHERE O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX2127618499 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX0339323878 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1531629550 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1365836084 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1336974557 ON LINEITEM ( L_ORDERKEY ); SELECT * FROM ORDERS RIGHT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY ; CREATE INDEX SQLLAB_IDX1002609246 ON ORDERS ( O_ORDERKEY ); SELECT * FROM ORDERS LEFT JOIN LINEITEM ON O_ORDERKEY = L_ORDERKEY WHERE l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX0711368375 ON LINEITEM ( L_ORDERKEY , L_SHIPDATE );","title":"Table Joins"},{"location":"pawreference/sql-syntax/#subqueries","text":"-- subquery1 select * from supplier ,( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) revenue where s_suppkey = revenue . l_suppkey ; CREATE INDEX SQLLAB_IDX0151075817 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1968327707 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE ); -- subquery2 select * from supplier where s_suppkey = ( select l_suppkey from lineitem order by l_suppkey desc limit 1 ); CREATE INDEX SQLLAB_IDX0664775210 ON SUPPLIER ( S_SUPPKEY ); -- subquery3 with revenue as ( select l_suppkey , sum ( l_extendedprice ) as total_revenue from lineitem group by l_suppkey ) select * from supplier , revenue where s_suppkey = l_suppkey ; CREATE INDEX SQLLAB_IDX0343576594 ON SUPPLIER ( S_SUPPKEY ); CREATE INDEX SQLLAB_IDX1518532301 ON LINEITEM ( L_SUPPKEY , L_EXTENDEDPRICE );","title":"Subqueries"},{"location":"pawreference/sql-syntax/#query-rewrite","text":"","title":"Query Rewrite"},{"location":"pawreference/sql-syntax/#1transitive-closure","text":"-- example 1 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey = 'ORD1234' ; CREATE INDEX SQLLAB_IDX0837835805 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1989932894 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 2 select o_custkey as cust_no , l_extendedprice * ( 1 - l_discount ) from orders , lineitem where l_orderkey = o_orderkey and l_orderkey > 'ORD1234' ; CREATE INDEX SQLLAB_IDX1000938250 ON ORDERS ( O_ORDERKEY , O_CUSTKEY ); CREATE INDEX SQLLAB_IDX1358517686 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE ); -- example 3 select c_custkey , c_name , sum ( l_extendedprice * ( 1 - l_discount )) as revenue from customer , orders , lineitem where c_custkey = o_orderkey and l_orderkey = o_orderkey and l_orderkey = 'ORD1234' group by c_custkey , c_name ; CREATE INDEX SQLLAB_IDX1161414921 ON ORDERS ( O_ORDERKEY ); CREATE INDEX SQLLAB_IDX1584481406 ON CUSTOMER ( C_CUSTKEY , C_NAME ); CREATE INDEX SQLLAB_IDX0637857516 ON LINEITEM ( L_ORDERKEY , L_DISCOUNT , L_EXTENDEDPRICE );","title":"1.Transitive Closure"},{"location":"pawreference/sql-syntax/#2ordinal","text":"-- orderby ordinal select * from lineitem order by l_shipdate limit 10 CREATE INDEX SQLLAB_IDX1424903467 ON LINEITEM ( L_SHIPDATE ); sql -- groupby ordinal select l_shipdate , sum ( l_quantity ) as sum_qty from lineitem group by 1 CREATE INDEX SQLLAB_IDX1614428511 ON LINEITEM ( L_SHIPDATE , L_QUANTITY );","title":"2.Ordinal"},{"location":"pawreference/sql-syntax/#updatedeleteinsertmerge","text":"delete from lineitem where l_shipdate = date '1998-12-01' ; CREATE INDEX SQLLAB_IDX1533504424 ON LINEITEM ( L_SHIPDATE ); update lineitem set l_shipmode = '' where l_shipmode is null ; CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); insert into lineitem select * from lineitem where l_shipmode in ( '0' ); CREATE INDEX SQLLAB_IDX2000792795 ON LINEITEM ( L_SHIPMODE ); replace into lineitem select * where l_shipdate = date '1998-12-01' and l_shipmode = '0' ; CREATE INDEX SQLLAB_IDX1942674217 ON LINEITEM ( L_SHIPDATE , L_SHIPMODE );","title":"Update/Delete/Insert/Merge"},{"location":"pawsqladvisor/","text":"What is PawSQL Advisor \u00b6 In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click . Features \u00b6 Rules-based SQL auditing, targeting correctness auditing and performance optimization. Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation, based on input SQL syntax, database objects and statistics information. What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations. Get started \u00b6 Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization options will be presented to you. Tip: PawSQL Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get Started"},{"location":"pawsqladvisor/#what-is-pawsql-advisor","text":"In addition to integrating the powerful index recommendation function of Paw Index Advisor , PawSQL Advisor also integrates the industry's best practices for query optimization for relational databases, and audits and rewrites SQL capatility from the aspects of correctness and performance. PawSQL Advisor is integrated with the most popular IDE, such as IntelliJ IDEA , PhpStorm, PyCharm , WebStorm. It helps database application developers and database administrator optimize their queries by One Click .","title":"What is PawSQL Advisor"},{"location":"pawsqladvisor/#features","text":"Rules-based SQL auditing, targeting correctness auditing and performance optimization. Rewrite optimization, recommended semantically equivalent, but more efficient SQL. Intelligent index recommendation, based on input SQL syntax, database objects and statistics information. What-if analysis to ensure gaining better performance after SQL rewriting and indexing recommendations.","title":"Features"},{"location":"pawsqladvisor/#get-started","text":"Start the JetBrains integrated development environment(IntelliJ IDEA, CLion, PyCharm and etc,), open the project Setting, select Plugins; Enter \"PawSQL Advisor\" in Marketplace and click Install; Configure the running parameters of PawSQL Advisor on the Setting page; Right-click on the SQL file or folder to be analyzed, and click \"Run PawSQL Advisor\"; Wait for a while and the optimization options will be presented to you. Tip: PawSQL Advisor is delivered as a beta version for free trial. You are welcomed to file bugs at https://pawsql.youtrack.cloud/newIssue .","title":"Get started"},{"location":"pawsqladvisor/change-log/","text":"Changelog \u00b6 1.0.109 _ August 13, 2022 \u00b6 Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue. 0.1.108 _ Aug 4, 2022 \u00b6 Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12. 0.1.106 _ Aug 4, 2022 \u00b6 Initial beta release.","title":"Change Log"},{"location":"pawsqladvisor/change-log/#changelog","text":"","title":"Changelog"},{"location":"pawsqladvisor/change-log/#0.1.109","text":"Improve Paw DDL parser to support \"create if not exists\". For Postgres databases, explaining update statements is not supported, rewrite update statement to select during validation. For MySQL databases under version 5.6, explaining dml(delete/update/insert statements) are not supported, rewrite dml statements to select during validation. Add serverTimezone=UTC to connection url to fix timezone different issue.","title":"1.0.109 _ August 13, 2022"},{"location":"pawsqladvisor/change-log/#0.1.108","text":"Fix a bug when table/column references are quoted with \"`\". Support validation for MySQL with version under 8.0.12.","title":"0.1.108 _ Aug 4, 2022"},{"location":"pawsqladvisor/change-log/#0.1.106","text":"Initial beta release.","title":"0.1.106 _ Aug 4, 2022"},{"location":"pawsqladvisor/configuration/","text":"Configuration \u00b6 You can configure and control the execution process on the PawSQL Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation Query Type \u00b6 Specifies the type of input SQL statements. PawSQL Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, PawSQL Advisor will parse those file and permutes all possible SQL combinations. PawSQL Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some of the combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog. Database Vendor \u00b6 Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested. Connection Info \u00b6 Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance. Database host \u00b6 Ip address or host name of the database server Database port \u00b6 Port of the connection to the database server User \u00b6 User name to connect to the database server Password \u00b6 The password of the user connecting to the database server DefaultDB \u00b6 The default database name when connecting to the database server Database/schema List \u00b6 For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b Deduplicate with existing indexes \u00b6 If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index. What-if analysis validation \u00b6 If this option is checked, PawSQL Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), PawSQL Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"Configuration"},{"location":"pawsqladvisor/configuration/#configuration","text":"You can configure and control the execution process on the PawSQL Advisor plugin Configuration page. Query Type Database Vendor Connection Info Deduplicate with existing indexes What-if analysis validation","title":"Configuration"},{"location":"pawsqladvisor/configuration/#query-type","text":"Specifies the type of input SQL statements. PawSQL Advisor currently supports two type of input SQL statements. SQL files If this option is selected, it means the inputs are native SQL files; The detailed syntax and corresponding index recommendations are described in detail in SQL syntax and Indexes . Map files If this option is selected, it means the inputs are Mybatis' mapper configuration file, PawSQL Advisor will parse those file and permutes all possible SQL combinations. PawSQL Advisor uses an intelligent engine to infer the data type of placeholders in a mapper file based on their context and assign them a valid constant, enabling it to produce legitimate SQL statements for subsequent query statement structure analysis. Mapper files as input is very important for application developers, because in the early stages of application development, developers can not fully grasp the input combination of the front-end, the SQL business that can be combined can not be determined, this option can ensure that for all combinations, the appropriate index recommendation can be made to improve performance. Due to some of the combined SQL statements will never appear in the real production enviroment, and some useless indexes are recommended based those combinition. Therefore, it is recommended to use the Paw Index Advisor again after the application is on production, or in the UAT testing stage, with the real SQL as input through the querylog.","title":"Query Type"},{"location":"pawsqladvisor/configuration/#database-vendor","text":"Specifies the database type on which the SQL optimization is performance. PawSQL currently supports three database types: MySQL PostgreSQL Opengauss Other databases based on the MySQL/PostgreSQL client protocol are theoretically supported, but have not been fully tested.","title":"Database Vendor"},{"location":"pawsqladvisor/configuration/#connection-info","text":"Database connection information serves two purposes: Obtain the database objects, including database tables, column definitions, and existing index information. Tip: The database objects are crucial to query optimization. PawSQL SQL Parser uses them to resolve the table names and column names refered in the SQL statements, and they will be use in following query rewrite optimization and index recommendation. Verify the the rewrite optimization and recommended indexes to ensure that the they can be selected in the actual SQL execution plan, thereby improving sql query performance.","title":"Connection Info"},{"location":"pawsqladvisor/configuration/#database-host","text":"Ip address or host name of the database server","title":"Database host"},{"location":"pawsqladvisor/configuration/#database-port","text":"Port of the connection to the database server","title":"Database port"},{"location":"pawsqladvisor/configuration/#user","text":"User name to connect to the database server","title":"User"},{"location":"pawsqladvisor/configuration/#password","text":"The password of the user connecting to the database server","title":"Password"},{"location":"pawsqladvisor/configuration/#defaultdb","text":"The default database name when connecting to the database server","title":"DefaultDB"},{"location":"pawsqladvisor/configuration/#databaseschema-list","text":"For MySQL type of databases, it's a string of database names, like tpch, tpds For postgres/opengauss type databases, it's a string of schema names, like schema_a, schema_b","title":"Database/schema List"},{"location":"pawsqladvisor/configuration/#deduplicate-with-existing-indexes","text":"If this option is checked and the candidate indexes is covered by existing indexes, those candidate indexes will NOT be considered in the final recommendation. Tip: This option should be checked when you are not considering dropping existing indexes. This is common because the input SQL statements are not representative of all the queries running against this database. Therefore, only consider adding new indexes that are helpful for input SQL statements. If you can ensure that the input SQL statements contains all the queries running against this database, you can keep only the recommended indexes, in which case you can uncheck this option and use the newly recommended index instead of the existing index.","title":"Deduplicate with existing indexes"},{"location":"pawsqladvisor/configuration/#what-if-analysis-validation","text":"If this option is checked, PawSQL Advisor will do a what-if validation to ensure that the recommended indexes are selected in the actual SQL execution plan to avoid recommending useless indexes. Tip: Checking this option should be very careful under production enviroments. Because for those databases without built-in what-if (virtual indexes)capability (Neither MySQL or Postgres), PawSQL Advisor does the what-if validation by creating recommended indexes and performing explain commands to retrived execution plan for exclusive analysis, and then dropping the recommended indexes. This process consumes a certain amount of resources, and the execution time is relatively long, which may affect the business operation on the production servers.","title":"What-if analysis validation"},{"location":"pawsqladvisor/eula/","text":"End-User License Agreement (EULA) of PawSQL Advisor \u00b6 This EULA agreement governs your acquisition and use of our PawSQL Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the PawSQL Advisor software. It provides a license to use the PawSQL Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the PawSQL Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the PawSQL Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply. License Grant \u00b6 Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the PawSQL Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the PawSQL Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the PawSQL Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement Intellectual Property and Ownership \u00b6 Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties. Termination \u00b6 This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL. Governing Law \u00b6 This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"EULA"},{"location":"pawsqladvisor/eula/#end-user-license-agreement-eula-of-pawsql-advisor","text":"This EULA agreement governs your acquisition and use of our PawSQL Advisor software (\"Software\") directly from Paw SQL or indirectly through a Paw SQL authorized reseller or distributor (a \"Reseller\"). Please read this EULA agreement carefully before completing the installation process and using the PawSQL Advisor software. It provides a license to use the PawSQL Advisor software and contains warranty information and liability disclaimers. If you register for a free trial of the PawSQL Advisor software, this EULA agreement will also govern that trial. By clicking \"accept\" or installing and/or using the PawSQL Advisor software, you are confirming your acceptance of the Software and agreeing to become bound by the terms of this EULA agreement. If you are entering into this EULA agreement on behalf of a company or other legal entity, you represent that you have the authority to bind such entity and its affiliates to these terms and conditions. If you do not have such authority or if you do not agree with the terms and conditions of this EULA agreement, do not install or use the Software, and you must not accept this EULA agreement. This EULA agreement shall apply only to the Software supplied by Paw SQL herewith regardless of whether other software is referred to or described herein. The terms also apply to any Paw SQL updates, supplements, Internet-based services, and support services for the Software, unless other terms accompany those items on delivery. If so, those terms apply.","title":"End-User License Agreement (EULA) of PawSQL Advisor"},{"location":"pawsqladvisor/eula/#license-grant","text":"Paw SQL hereby grants you a personal, non-transferable, non-exclusive licence to use the PawSQL Advisor software on your devices in accordance with the terms of this EULA agreement. You are permitted to load the PawSQL Advisor software (for example a PC, laptop, mobile or tablet) under your control. You are responsible for ensuring your device meets the minimum requirements of the PawSQL Advisor software. You are not permitted to: Edit, alter, modify, adapt, translate or otherwise change the whole or any part of the Software nor permit the whole or any part of the Software to be combined with or become incorporated in any other software, nor decompile, disassemble or reverse engineer the Software or attempt to do any such things Reproduce, copy, distribute, resell or otherwise use the Software for any commercial purpose Allow any third party to use the Software on behalf of or for the benefit of any third party Use the Software in any way which breaches any applicable local, national or international law use the Software for any purpose that Paw SQL considers is a breach of this EULA agreement","title":"License Grant"},{"location":"pawsqladvisor/eula/#intellectual-property-and-ownership","text":"Paw SQL shall at all times retain ownership of the Software as originally downloaded by you and all subsequent downloads of the Software by you. The Software (and the copyright, and other intellectual property rights of whatever nature in the Software, including any modifications made thereto) are and shall remain the property of Paw SQL. Paw SQL reserves the right to grant licences to use the Software to third parties.","title":"Intellectual Property and Ownership"},{"location":"pawsqladvisor/eula/#termination","text":"This EULA agreement is effective from the date you first use the Software and shall continue until terminated. You may terminate it at any time upon written notice to Paw SQL.","title":"Termination"},{"location":"pawsqladvisor/eula/#governing-law","text":"This EULA agreement, and any dispute arising out of or in connection with this EULA agreement, shall be governed by and construed in accordance with the laws of China, USA and other countries.","title":"Governing Law"},{"location":"pawsqladvisor/pawsummary/","text":"Tuning Summary \u00b6 After the tuning process is done, there is one summary file named pawSummary.sql and tuning detail files for each SQL query under a new sub-directory named tuningDetails . The outline is as follows: . \u251c\u2500 tuningDetails/ \u2502 \u2514\u2500 file1-stmt-1.txt \u2502 \u2514\u2500 file1-stmt-2.txt \u2502 \u2514\u2500 file2-stmt-1.txt \u2514\u2500 pawSummary.sql \u2514\u2500 file1.sql \u2514\u2500 file2.sql 1. Tuning Summary \u00b6 The first section briefly describes the overall of the tuning, including the number of query analyzed, the number of queries which are applied rewrite optimization to, the number of rewrite optimizations applied, the number of queries are which applied rule auditing to, the number of violations of auditing rules, the number of indexes recommended, the number of queries for which the indexes are recommended the overall perfomance improvement 1. Tuning Summary - There are 26 query analyzed; - There are 5 optimization rewrites for 5 queries; - There are 18 violations of optimization rule against 12 queries; - There are 33 indices recommended for 22 queries; - There is 11936685010280.29% performance improvement. 2. Optimization Rule Violations \u00b6 The second section describle what auditing rules violated or what rewrite optimization applied, and what queries are applied by those auditing rules or rewrite optimizations. 2. Optimization Rule Violations - RuleFuncWithColumnInPredicate: [22.sql-stmt1] - RuleUseEqual4Null: [R0015.sql-stmt2, R0015.sql-stmt1, R0015.sql-stmt3] - RuleNumOfJoinTables: [9.sql-stmt1, 5.sql-stmt1, 8.sql-stmt1, 2.sql-stmt1, 7.sql-stmt1] - RulePredicateLikeStartWithWildcard: [9.sql-stmt1, 13.sql-stmt1, 16.sql-stmt1, 2.sql-stmt1] - RuleUnion2UnionAll: [19.sql-stmt1] - RuleOrCond4SelectRewrite: [19.sql-stmt1] - RuleNumOfLevelOfSubQuery: [19.sql-stmt1] - RuleMaxMinAggRewrite: [2.sql-stmt1] 3. Recommended Indexes \u00b6 The third section lists all the indexes recommended by Index Advisor, if the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 . If the What-if analysis validation is checked, those indexes are verified to gain performance improvement. 3 . Recommended Indexes - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1816680539 ON TPCH . NATION ( N_NATIONKEY , N_NAME ); - CREATE INDEX PAW_IDX0156881833 ON TPCH . NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); - CREATE INDEX PAW_IDX0641962049 ON TPCH . LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0636918380 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_SUPPKEY , L_COMMITDATE ); - CREATE INDEX PAW_IDX1352680166 ON TPCH . LINEITEM ( L_SHIPMODE , L_RECEIPTDATE ); - CREATE INDEX PAW_IDX0137309144 ON TPCH . LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1021669930 ON TPCH . LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0151075817 ON TPCH . LINEITEM ( L_ORDERKEY , L_SUPPKEY ); - CREATE INDEX PAW_IDX0025038833 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_SUPPKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX1496549982 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_ORDERKEY ); - CREATE INDEX PAW_IDX0664775210 ON TPCH . LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); - CREATE INDEX PAW_IDX1318724089 ON TPCH . LINEITEM ( L_ORDERKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX2016121426 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1809130098 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); - CREATE INDEX PAW_IDX1831397382 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX1974481774 ON TPCH . CUSTOMER ( C_ACCTBAL , C_PHONE ); - CREATE INDEX PAW_IDX0499202881 ON TPCH . CUSTOMER ( C_NATIONKEY , C_CUSTKEY ); - CREATE INDEX PAW_IDX2038863975 ON TPCH . CUSTOMER ( C_CUSTKEY , C_NAME ( 16 )); - CREATE INDEX PAW_IDX2008453396 ON TPCH . CUSTOMER ( C_MKTSEGMENT , C_CUSTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); ... 4. Optimized Query List \u00b6 The fourth section lists each the SQL query together with its performance improvement, the cost before tuning, the cost after tuning, and the recommended indexes contribute to its performance improvement. Notice : If What-if analysis validation isn't checked, PawSQL Advisor will NOT get those information in this section. 4. Optimized Query List - 1.sql-stmt1, performance improves by 1041484.5070422536%[costBefore=7395.25,costAfter=0.71] -- Contributing indices:[PAW_IDX1831397382] - 10.sql-stmt1, performance improves by 1.7989040997273477E11%[costBefore=4.1374794316729E11,costAfter=230.0] -- Contributing indices:[PAW_IDX1409884827, PAW_IDX1021669930, PAW_IDX2038863975, PAW_IDX1816680539] - 11.sql-stmt1, performance improves by 2.5246486123619478E12%[costBefore=5.3143853292324E11,costAfter=21.05] -- Contributing indices:[PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX0949237515, PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX1586215289] - 12.sql-stmt1, performance improves by 436812.6436781609%[costBefore=7602.28,costAfter=1.74] -- Contributing indices:[PAW_IDX1352680166, PAW_IDX0538538531] - 13.sql-stmt1, performance improves by -99.99757285582929%[costBefore=2.5,costAfter=103001.71] -- Contributing indices:[PAW_IDX2038863975, PAW_IDX1403958132] - 14.sql-stmt1, performance improves by 3.6741429030575542E9%[costBefore=6.1284705291E8,costAfter=16.68] -- Contributing indices:[PAW_IDX0025038833, PAW_IDX0719788224] - 15.sql-stmt1, performance improves by 9308930.025445294%[costBefore=365844.88,costAfter=3.93] -- Contributing indices:[PAW_IDX1831397382, PAW_IDX1452901602] - 16.sql-stmt1, performance improves by 3093767.4732323023%[costBefore=2.04892949245268E13,costAfter=6.622550934E8] -- Contributing indices:[PAW_IDX1645425553, PAW_IDX0326568991, <AUTO_DISTINCT_KEY>] - 17.sql-stmt1, performance improves by 1.5561515563380282E9%[costBefore=5.52433838E7,costAfter=3.55] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX0664775210, PAW_IDX1809130098] - 18.sql-stmt1, performance improves by 110588.99568547281%[costBefore=1.905657921778E10,costAfter=1.721632679E7] -- Contributing indices:[PAW_IDX1403958132, <AUTO_DISTINCT_KEY>, PAW_IDX1318724089, PAW_IDX1318724089] - 19.sql-stmt1, performance improves by 2.0183056542168677E9%[costBefore=3.350387552E7,costAfter=1.66] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX1352680166] - 2.sql-stmt1, performance improves by 8.6010577952777552E16%[costBefore=1.36688870588333773E18,costAfter=1589.21] -- Contributing indices:[PAW_IDX0094600326, PAW_IDX1645425553, PAW_IDX1922219213, PAW_IDX0094600326, PAW_IDX0326568991, PAW_IDX1452901602, PAW_IDX1352808126, PAW_IDX1452901602, PAW_IDX1352808126] ... The de-duplication alogrithm is adhere to left-most prefix principle. \u21a9","title":"Tuning Summary"},{"location":"pawsqladvisor/pawsummary/#tuning-summary","text":"After the tuning process is done, there is one summary file named pawSummary.sql and tuning detail files for each SQL query under a new sub-directory named tuningDetails . The outline is as follows: . \u251c\u2500 tuningDetails/ \u2502 \u2514\u2500 file1-stmt-1.txt \u2502 \u2514\u2500 file1-stmt-2.txt \u2502 \u2514\u2500 file2-stmt-1.txt \u2514\u2500 pawSummary.sql \u2514\u2500 file1.sql \u2514\u2500 file2.sql","title":"Tuning Summary"},{"location":"pawsqladvisor/pawsummary/#1-tuning-summary","text":"The first section briefly describes the overall of the tuning, including the number of query analyzed, the number of queries which are applied rewrite optimization to, the number of rewrite optimizations applied, the number of queries are which applied rule auditing to, the number of violations of auditing rules, the number of indexes recommended, the number of queries for which the indexes are recommended the overall perfomance improvement 1. Tuning Summary - There are 26 query analyzed; - There are 5 optimization rewrites for 5 queries; - There are 18 violations of optimization rule against 12 queries; - There are 33 indices recommended for 22 queries; - There is 11936685010280.29% performance improvement.","title":"1. Tuning Summary"},{"location":"pawsqladvisor/pawsummary/#2-optimization-rule-violations","text":"The second section describle what auditing rules violated or what rewrite optimization applied, and what queries are applied by those auditing rules or rewrite optimizations. 2. Optimization Rule Violations - RuleFuncWithColumnInPredicate: [22.sql-stmt1] - RuleUseEqual4Null: [R0015.sql-stmt2, R0015.sql-stmt1, R0015.sql-stmt3] - RuleNumOfJoinTables: [9.sql-stmt1, 5.sql-stmt1, 8.sql-stmt1, 2.sql-stmt1, 7.sql-stmt1] - RulePredicateLikeStartWithWildcard: [9.sql-stmt1, 13.sql-stmt1, 16.sql-stmt1, 2.sql-stmt1] - RuleUnion2UnionAll: [19.sql-stmt1] - RuleOrCond4SelectRewrite: [19.sql-stmt1] - RuleNumOfLevelOfSubQuery: [19.sql-stmt1] - RuleMaxMinAggRewrite: [2.sql-stmt1]","title":"2. Optimization Rule Violations"},{"location":"pawsqladvisor/pawsummary/#3-recommended-indexes","text":"The third section lists all the indexes recommended by Index Advisor, if the Deduplicate with existing indexes is checked, those indexes are de-duplicated with existing Index 1 . If the What-if analysis validation is checked, those indexes are verified to gain performance improvement. 3 . Recommended Indexes - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1816680539 ON TPCH . NATION ( N_NATIONKEY , N_NAME ); - CREATE INDEX PAW_IDX0156881833 ON TPCH . NATION ( N_NAME , N_NATIONKEY , N_REGIONKEY ); - CREATE INDEX PAW_IDX0641962049 ON TPCH . LINEITEM ( L_ORDERKEY , L_SHIPDATE , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0636918380 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_SUPPKEY , L_COMMITDATE ); - CREATE INDEX PAW_IDX1352680166 ON TPCH . LINEITEM ( L_SHIPMODE , L_RECEIPTDATE ); - CREATE INDEX PAW_IDX0137309144 ON TPCH . LINEITEM ( L_SUPPKEY , L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1021669930 ON TPCH . LINEITEM ( L_RETURNFLAG , L_ORDERKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX0151075817 ON TPCH . LINEITEM ( L_ORDERKEY , L_SUPPKEY ); - CREATE INDEX PAW_IDX0025038833 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_SUPPKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX1496549982 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_ORDERKEY ); - CREATE INDEX PAW_IDX0664775210 ON TPCH . LINEITEM ( L_PARTKEY , L_QUANTITY , L_EXTENDEDPRICE ); - CREATE INDEX PAW_IDX1318724089 ON TPCH . LINEITEM ( L_ORDERKEY , L_QUANTITY ); - CREATE INDEX PAW_IDX2016121426 ON TPCH . LINEITEM ( L_ORDERKEY , L_RECEIPTDATE , L_COMMITDATE ); - CREATE INDEX PAW_IDX1809130098 ON TPCH . LINEITEM ( L_PARTKEY , L_SUPPKEY , L_SHIPDATE , L_QUANTITY ); - CREATE INDEX PAW_IDX1831397382 ON TPCH . LINEITEM ( L_SHIPDATE , L_PARTKEY , L_EXTENDEDPRICE , L_DISCOUNT ); - CREATE INDEX PAW_IDX1974481774 ON TPCH . CUSTOMER ( C_ACCTBAL , C_PHONE ); - CREATE INDEX PAW_IDX0499202881 ON TPCH . CUSTOMER ( C_NATIONKEY , C_CUSTKEY ); - CREATE INDEX PAW_IDX2038863975 ON TPCH . CUSTOMER ( C_CUSTKEY , C_NAME ( 16 )); - CREATE INDEX PAW_IDX2008453396 ON TPCH . CUSTOMER ( C_MKTSEGMENT , C_CUSTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); ...","title":"3. Recommended Indexes"},{"location":"pawsqladvisor/pawsummary/#4-optimized-query-list","text":"The fourth section lists each the SQL query together with its performance improvement, the cost before tuning, the cost after tuning, and the recommended indexes contribute to its performance improvement. Notice : If What-if analysis validation isn't checked, PawSQL Advisor will NOT get those information in this section. 4. Optimized Query List - 1.sql-stmt1, performance improves by 1041484.5070422536%[costBefore=7395.25,costAfter=0.71] -- Contributing indices:[PAW_IDX1831397382] - 10.sql-stmt1, performance improves by 1.7989040997273477E11%[costBefore=4.1374794316729E11,costAfter=230.0] -- Contributing indices:[PAW_IDX1409884827, PAW_IDX1021669930, PAW_IDX2038863975, PAW_IDX1816680539] - 11.sql-stmt1, performance improves by 2.5246486123619478E12%[costBefore=5.3143853292324E11,costAfter=21.05] -- Contributing indices:[PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX0949237515, PAW_IDX0156881833, PAW_IDX1620687743, PAW_IDX1586215289] - 12.sql-stmt1, performance improves by 436812.6436781609%[costBefore=7602.28,costAfter=1.74] -- Contributing indices:[PAW_IDX1352680166, PAW_IDX0538538531] - 13.sql-stmt1, performance improves by -99.99757285582929%[costBefore=2.5,costAfter=103001.71] -- Contributing indices:[PAW_IDX2038863975, PAW_IDX1403958132] - 14.sql-stmt1, performance improves by 3.6741429030575542E9%[costBefore=6.1284705291E8,costAfter=16.68] -- Contributing indices:[PAW_IDX0025038833, PAW_IDX0719788224] - 15.sql-stmt1, performance improves by 9308930.025445294%[costBefore=365844.88,costAfter=3.93] -- Contributing indices:[PAW_IDX1831397382, PAW_IDX1452901602] - 16.sql-stmt1, performance improves by 3093767.4732323023%[costBefore=2.04892949245268E13,costAfter=6.622550934E8] -- Contributing indices:[PAW_IDX1645425553, PAW_IDX0326568991, <AUTO_DISTINCT_KEY>] - 17.sql-stmt1, performance improves by 1.5561515563380282E9%[costBefore=5.52433838E7,costAfter=3.55] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX0664775210, PAW_IDX1809130098] - 18.sql-stmt1, performance improves by 110588.99568547281%[costBefore=1.905657921778E10,costAfter=1.721632679E7] -- Contributing indices:[PAW_IDX1403958132, <AUTO_DISTINCT_KEY>, PAW_IDX1318724089, PAW_IDX1318724089] - 19.sql-stmt1, performance improves by 2.0183056542168677E9%[costBefore=3.350387552E7,costAfter=1.66] -- Contributing indices:[PAW_IDX0277758219, PAW_IDX1352680166] - 2.sql-stmt1, performance improves by 8.6010577952777552E16%[costBefore=1.36688870588333773E18,costAfter=1589.21] -- Contributing indices:[PAW_IDX0094600326, PAW_IDX1645425553, PAW_IDX1922219213, PAW_IDX0094600326, PAW_IDX0326568991, PAW_IDX1452901602, PAW_IDX1352808126, PAW_IDX1452901602, PAW_IDX1352808126] ... The de-duplication alogrithm is adhere to left-most prefix principle. \u21a9","title":"4. Optimized Query List"},{"location":"pawsqladvisor/tuningdetails/","text":"Tuning Details \u00b6 For each tuned query, there is a correspending tuning details file produced to show you WHAT and HOW the query is tuned, HOW MUCH does its performance improve and ect. There are FIVE sections in this statement level tuning detail result file, as follows. 1. Original Query \u00b6 1 . Original Query ( formatted ) select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select min ( partsupp . ps_supplycost ) from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ))) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ; 2. Rewritten Query \u00b6 2 . Rewritten Query - Rule : RuleMaxMinAggRewrite select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select partsupp . ps_supplycost from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ) order by partsupp . ps_supplycost asc limit 1 )) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ; 3. Auditing Rule Violations \u00b6 3 . Auditing Rule Violations - Rule : RulePredicateLikeStartWithWildcard - Violation Parts : part . p_type like '%STEEL' ; - Rule : RuleNumOfJoinTables ( threshold -> 5 ) - Violation Parts : FROM TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region ; 4. Index Recommended \u00b6 Indexes recommended by Paw Advisor and contribute to this SQL query will be listed below. 4 . Index Recommended - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX1645425553 ON TPCH . PART ( P_SIZE , P_TYPE ( 16 ), P_BRAND ); - CREATE INDEX PAW_IDX1922219213 ON TPCH . PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX0326568991 ON TPCH . PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); 5. Validation Details \u00b6 5 . Validation Details 5 . 1 Performance improves by 2 . 67 E16 % - cost_before = 2 . 7375641592668303 E18 - cost_after = 10234 . 800000000001 5 . 2 Query Plan ( before ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Inner hash join ( part . P_PARTKEY = partsupp . PS_PARTKEY ), ( partsupp . PS_SUPPLYCOST = ( select # 2 )) ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Filter : (( part . P_SIZE = 30 ) and ( part . P_TYPE like '%STEEL' )) ( cost = 282 . 66 rows = 774 ) -> Table scan on part ( cost = 282 . 66 rows = 697018 ) -> Hash -> Inner hash join ( partsupp . PS_SUPPKEY = supplier . S_SUPPKEY ) ( cost = 3786224480556435 . 50 rows = 3785350948227630 ) -> Table scan on partsupp ( cost = 0 . 67 rows = 72391 ) -> Hash -> Inner hash join ( supplier . S_NATIONKEY = nation . N_NATIONKEY ) ( cost = 522968063410 . 36 rows = 522903522789 ) -> Table scan on supplier ( cost = 0 . 25 rows = 101512 ) -> Hash -> Inner hash join ( nation . N_REGIONKEY = region . R_REGIONKEY ) ( cost = 51519510 . 02 rows = 51511498 ) -> Table scan on nation ( cost = 0 . 20 rows = 72308 ) -> Hash -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 7308 . 15 rows = 7124 ) -> Table scan on region ( cost = 7308 . 15 rows = 71239 ) 5 . 3 Query Plan ( after ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1562 . 36 rows = 24 ) -> Nested loop inner join ( cost = 1553 . 82 rows = 7 ) -> Nested loop inner join ( cost = 1354 . 61 rows = 142 ) -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Filter : ( part . P_TYPE like '%STEEL' ) ( cost = 1240 . 09 rows = 142 ) -> Index lookup on part using PAW_IDX1645425553 ( P_SIZE = 30 ) ( cost = 1240 . 09 rows = 1276 ) -> Filter : (( partsupp . PS_PARTKEY = part . P_PARTKEY ) and ( partsupp . PS_SUPPLYCOST = ( select # 2 ))) ( cost = 1 . 01 rows = 0 . 05 ) -> Covering index lookup on partsupp using PAW_IDX1922219213 ( PS_SUPPLYCOST = ( select # 2 )) ( cost = 1 . 01 rows = 4 ) -> Select # 2 ( subquery in condition ; dependent ) -> Aggregate : min ( partsupp . PS_SUPPLYCOST ) ( cost = 41 . 31 rows = 1 ) -> Nested loop inner join ( cost = 38 . 82 rows = 25 ) -> Nested loop inner join ( cost = 11 . 53 rows = 25 ) -> Nested loop inner join ( cost = 2 . 84 rows = 7 ) -> Filter : ( region . R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on partsupp using PAW_IDX0326568991 ( PS_PARTKEY = part . P_PARTKEY ) ( cost = 1 . 74 rows = 7 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 )","title":"Tuning Details"},{"location":"pawsqladvisor/tuningdetails/#tuning-details","text":"For each tuned query, there is a correspending tuning details file produced to show you WHAT and HOW the query is tuned, HOW MUCH does its performance improve and ect. There are FIVE sections in this statement level tuning detail result file, as follows.","title":"Tuning Details"},{"location":"pawsqladvisor/tuningdetails/#1-original-query","text":"1 . Original Query ( formatted ) select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select min ( partsupp . ps_supplycost ) from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ))) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ;","title":"1. Original Query"},{"location":"pawsqladvisor/tuningdetails/#2-rewritten-query","text":"2 . Rewritten Query - Rule : RuleMaxMinAggRewrite select supplier . s_acctbal , supplier . s_name , nation . n_name , part . p_partkey , part . p_mfgr , supplier . s_address , supplier . s_phone , supplier . s_comment from TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region where ((((((( part . p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and part . p_size = 30 ) and part . p_type like '%STEEL' ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'ASIA' ) and partsupp . ps_supplycost = ( select partsupp . ps_supplycost from TPCH . partsupp , TPCH . supplier , TPCH . nation , TPCH . region where (((( p_partkey = partsupp . ps_partkey and supplier . s_suppkey = partsupp . ps_suppkey ) and supplier . s_nationkey = nation . n_nationkey ) and nation . n_regionkey = region . r_regionkey ) and region . r_name = 'A00007' ) order by partsupp . ps_supplycost asc limit 1 )) order by supplier . s_acctbal desc , nation . n_name , supplier . s_name , part . p_partkey limit 100 ;","title":"2. Rewritten Query"},{"location":"pawsqladvisor/tuningdetails/#3-auditing-rule-violations","text":"3 . Auditing Rule Violations - Rule : RulePredicateLikeStartWithWildcard - Violation Parts : part . p_type like '%STEEL' ; - Rule : RuleNumOfJoinTables ( threshold -> 5 ) - Violation Parts : FROM TPCH . part , TPCH . supplier , TPCH . partsupp , TPCH . nation , TPCH . region ;","title":"3. Auditing Rule Violations"},{"location":"pawsqladvisor/tuningdetails/#4-index-recommended","text":"Indexes recommended by Paw Advisor and contribute to this SQL query will be listed below. 4 . Index Recommended - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX1645425553 ON TPCH . PART ( P_SIZE , P_TYPE ( 16 ), P_BRAND ); - CREATE INDEX PAW_IDX1922219213 ON TPCH . PARTSUPP ( PS_SUPPLYCOST , PS_SUPPKEY , PS_PARTKEY ); - CREATE INDEX PAW_IDX0094600326 ON TPCH . REGION ( R_NAME , R_REGIONKEY ); - CREATE INDEX PAW_IDX0326568991 ON TPCH . PARTSUPP ( PS_PARTKEY , PS_SUPPKEY , PS_SUPPLYCOST , PS_AVAILQTY ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME ); - CREATE INDEX PAW_IDX1452901602 ON TPCH . SUPPLIER ( S_SUPPKEY , S_NAME , S_ADDRESS ( 16 ), S_PHONE ); - CREATE INDEX PAW_IDX1352808126 ON TPCH . NATION ( N_NATIONKEY , N_REGIONKEY , N_NAME );","title":"4. Index Recommended"},{"location":"pawsqladvisor/tuningdetails/#5-validation-details","text":"5 . Validation Details 5 . 1 Performance improves by 2 . 67 E16 % - cost_before = 2 . 7375641592668303 E18 - cost_after = 10234 . 800000000001 5 . 2 Query Plan ( before ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Inner hash join ( part . P_PARTKEY = partsupp . PS_PARTKEY ), ( partsupp . PS_SUPPLYCOST = ( select # 2 )) ( cost = 1366888705883337700 . 00 rows = 3256704261129158 ) -> Filter : (( part . P_SIZE = 30 ) and ( part . P_TYPE like '%STEEL' )) ( cost = 282 . 66 rows = 774 ) -> Table scan on part ( cost = 282 . 66 rows = 697018 ) -> Hash -> Inner hash join ( partsupp . PS_SUPPKEY = supplier . S_SUPPKEY ) ( cost = 3786224480556435 . 50 rows = 3785350948227630 ) -> Table scan on partsupp ( cost = 0 . 67 rows = 72391 ) -> Hash -> Inner hash join ( supplier . S_NATIONKEY = nation . N_NATIONKEY ) ( cost = 522968063410 . 36 rows = 522903522789 ) -> Table scan on supplier ( cost = 0 . 25 rows = 101512 ) -> Hash -> Inner hash join ( nation . N_REGIONKEY = region . R_REGIONKEY ) ( cost = 51519510 . 02 rows = 51511498 ) -> Table scan on nation ( cost = 0 . 20 rows = 72308 ) -> Hash -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 7308 . 15 rows = 7124 ) -> Table scan on region ( cost = 7308 . 15 rows = 71239 ) 5 . 3 Query Plan ( after ) -> Limit : 100 row ( s ) -> Sort : supplier . S_ACCTBAL DESC , nation . N_NAME , supplier . S_NAME , part . P_PARTKEY , limit input to 100 row ( s ) per chunk -> Stream results ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1589 . 18 rows = 24 ) -> Nested loop inner join ( cost = 1562 . 36 rows = 24 ) -> Nested loop inner join ( cost = 1553 . 82 rows = 7 ) -> Nested loop inner join ( cost = 1354 . 61 rows = 142 ) -> Filter : ( region . R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'ASIA' ) ( cost = 1 . 10 rows = 1 ) -> Filter : ( part . P_TYPE like '%STEEL' ) ( cost = 1240 . 09 rows = 142 ) -> Index lookup on part using PAW_IDX1645425553 ( P_SIZE = 30 ) ( cost = 1240 . 09 rows = 1276 ) -> Filter : (( partsupp . PS_PARTKEY = part . P_PARTKEY ) and ( partsupp . PS_SUPPLYCOST = ( select # 2 ))) ( cost = 1 . 01 rows = 0 . 05 ) -> Covering index lookup on partsupp using PAW_IDX1922219213 ( PS_SUPPLYCOST = ( select # 2 )) ( cost = 1 . 01 rows = 4 ) -> Select # 2 ( subquery in condition ; dependent ) -> Aggregate : min ( partsupp . PS_SUPPLYCOST ) ( cost = 41 . 31 rows = 1 ) -> Nested loop inner join ( cost = 38 . 82 rows = 25 ) -> Nested loop inner join ( cost = 11 . 53 rows = 25 ) -> Nested loop inner join ( cost = 2 . 84 rows = 7 ) -> Filter : ( region . R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on region using PAW_IDX0094600326 ( R_NAME = 'A00007' ) ( cost = 1 . 10 rows = 1 ) -> Covering index lookup on partsupp using PAW_IDX0326568991 ( PS_PARTKEY = part . P_PARTKEY ) ( cost = 1 . 74 rows = 7 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 ) -> Index lookup on supplier using PAW_IDX1452901602 ( S_SUPPKEY = partsupp . PS_SUPPKEY ) ( cost = 0 . 91 rows = 3 ) -> Covering index lookup on nation using PAW_IDX1352808126 ( N_NATIONKEY = supplier . S_NATIONKEY , N_REGIONKEY = region . R_REGIONKEY ) ( cost = 1 . 00 rows = 1 )","title":"5. Validation Details"}]}